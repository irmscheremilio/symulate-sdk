# Symulate SDK

AI-powered frontend-first development toolkit. Build your frontend without waiting for a backend.

## Features

- **Zero Backend Dependency**: Develop frontend-first with automatic mock data generation
- **AI-Powered Mocks**: Realistic data generated by OpenAI with intelligent caching
- **Database Schema Sync**: Reference backend database types directly with `m.db()`
- **Faker.js Mode**: Offline mode for CI/CD pipelines - no AI dependency required
- **Schema-Based Type System**: Zod-like schema builder for single source of truth
- **Type-Safe**: Full TypeScript support with automatic type inference
- **Seamless Production Switch**: One config change to switch from mocks to real backend
- **Smart Caching**: In-memory, localStorage, or file-based caching strategies
- **Performance Optimized**: <10ms mock generation after first AI cache
- **OpenAPI Generation**: Auto-generate API specs for backend developers
- **CI/CD Ready**: Deterministic Faker.js mode with seed support for testing
- **Breaking Change Detection**: Automatic detection of schema changes that break frontend code

## Installation

```bash
npm install @symulate/sdk
```

## Quick Start

```typescript
import { defineEndpoint, configureSymulate, m, type Infer } from "@symulate/sdk";

// Configure Symulate
// Get your free API key and project ID at https://platform.symulate.dev
configureSymulate({
  symulateApiKey: process.env.SYMULATE_API_KEY,
  projectId: process.env.SYMULATE_PROJECT_ID, // Required for API requests
  backendBaseUrl: "https://api.myapp.com", // For production
  environment: process.env.NODE_ENV === "production" ? "production" : "development",
  cacheEnabled: true,
  persistentCache: true, // Enable localStorage persistence in browser
});

// Define schema
const UserSchema = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  email: m.email(),
});

// Infer TypeScript type
type User = Infer<typeof UserSchema>;

// Define endpoint
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET",
  schema: UserSchema,
  mock: {
    count: 5,
  },
});

// Use it
const users = await getUsers();
console.log(users); // Fully typed as User[]
```

## Open Source & Free - Three Usage Modes

Symulate SDK is **fully open source** (MIT License) and can be used completely free. Choose the mode that fits your needs:

### üéØ Mode 1: Faker Mode (100% Free, No API Key)

Perfect for CI/CD, testing, and basic prototyping. No API keys required at all!

```typescript
import { defineEndpoint, configureSymulate, m } from "@symulate/sdk";

// No API key needed!
configureSymulate({
  generateMode: "faker", // Uses Faker.js for deterministic data
});

const UserSchema = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  email: m.email(),
});

export const getUsers = defineEndpoint({
  path: "/api/users",
  method: "GET",
  schema: UserSchema,
  mock: { count: 10 },
});

// Use it - completely free!
const users = await getUsers();
```

### üöÄ Mode 2: BYOK - Bring Your Own Key (OpenAI)

Get AI-powered realistic data with your own OpenAI API key. No Symulate account needed!

```typescript
import { defineCollection, configureSymulate, m, type Infer } from "@symulate/sdk";

// Configure with your OpenAI API key
configureSymulate({
  openaiApiKey: process.env.OPENAI_API_KEY, // Your OpenAI key
  generateMode: "ai", // Use AI generation
  // persistence defaults to "local" automatically!
});

// Define a collection with full CRUD operations
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.string(),
  price: m.number({ min: 10, max: 1000 }),
  category: m.string(),
  inStock: m.boolean(),
});

export type Product = Infer<typeof ProductSchema>;

export const products = defineCollection<Product>({
  name: "products",
  basePath: "/api/products",
  schema: ProductSchema,
  seedCount: 20,
  seedInstruction: "Generate realistic e-commerce products",
});

// Use it - full CRUD with AI-generated data
const { data } = await products.list();
await products.create({ name: "New Item", price: 29.99, category: "Electronics", inStock: true });
await products.update("id", { price: 24.99 });
await products.delete("id");
```

### üíº Mode 3: Symulate Platform (Paid, Full Features)

Get cloud hosting, team collaboration, branch isolation, and priority support.

```typescript
configureSymulate({
  symulateApiKey: process.env.SYMULATE_API_KEY,
  projectId: process.env.SYMULATE_PROJECT_ID,
  generateMode: "ai", // AI included
  // Cloud persistence automatic
});
```

### Feature Comparison

| Feature | Faker Mode | BYOK (OpenAI) | Symulate Platform |
|---------|-----------|---------------|-------------------|
| **Cost** | üéâ **100% Free** | ~$0.001/generation | Starting $49/month |
| **API Key Required** | ‚ùå None | Your OpenAI key | Platform key (included) |
| **Data Quality** | Basic (Faker.js) | ‚ú® AI-realistic | ‚ú® AI-realistic |
| **CRUD Collections** | ‚úÖ Full support | ‚úÖ Full support | ‚úÖ Full support |
| **Endpoints** | ‚úÖ Full support | ‚úÖ Full support | ‚úÖ Full support |
| **Persistence** | Memory/Local | ‚úÖ Local (auto) | ‚úÖ Cloud + Local |
| **Delay Simulation** | ‚úÖ | ‚úÖ | ‚úÖ |
| **Error Simulation** | ‚úÖ | ‚úÖ | ‚úÖ |
| **Branch Isolation** | ‚ùå | ‚ùå | ‚úÖ Multi-tenant |
| **Team Collaboration** | ‚ùå | ‚ùå | ‚úÖ Shared access |
| **Custom Domains** | ‚ùå | ‚ùå | ‚úÖ demo.agency.com |
| **Analytics** | ‚ùå | ‚ùå | ‚úÖ Usage tracking |
| **Support** | Community | Community | Priority |

### Which Mode to Choose?

**üéØ Choose Faker Mode if:**
- You're running CI/CD pipelines
- You need deterministic test data
- You want to prototype without any setup
- You don't need realistic data (just valid data)
- You want 100% free forever

**üöÄ Choose BYOK if:**
- You want AI-realistic data
- You're an individual developer or small team
- You have your own OpenAI API key
- You need local persistence (no cloud)
- You want full SDK features without vendor lock-in
- Perfect for: personal projects, prototyping, learning

**üíº Choose Platform if:**
- You're an agency needing client-specific demos
- You need branch isolation (multi-tenant data)
- You want team collaboration features
- You need cloud hosting without setup
- You need professional support
- Perfect for: agencies, teams, production use

### Getting Started (Free Forever)

**Option 1: Faker Mode (Zero Setup)**
```bash
npm install @symulate/sdk
```
```typescript
import { configureSymulate } from "@symulate/sdk";

configureSymulate({
  generateMode: "faker", // That's it! No API key needed
});
```

**Option 2: BYOK with OpenAI**
1. Get an OpenAI API key at [https://platform.openai.com/api-keys](https://platform.openai.com/api-keys)
2. Install Symulate SDK:
   ```bash
   npm install @symulate/sdk
   ```
3. Configure (persistence is automatic!):
   ```typescript
   configureSymulate({
     openaiApiKey: process.env.OPENAI_API_KEY,
     generateMode: "ai",
     // That's it! Persistence defaults to "local" automatically
   });
   ```
4. Start building with AI-realistic data!

**Full Example:** See [examples/byok-example.ts](./examples/byok-example.ts) for a complete working example.

## Configuration

Get your free API key and project ID at [https://platform.symulate.dev](https://platform.symulate.dev)

```typescript
configureSymulate({
  // API Keys (choose one):
  openaiApiKey: string,          // BYOK: Your OpenAI API key (sk-...) - for free open source tier
  symulateApiKey: string,        // Symulate Platform API key (sym_live_xxx) - for managed service

  // Optional:
  projectId: string,             // Project ID for multi-project isolation (required for platform)
  demoApiKey: string,            // Demo API key (sym_demo_xxx) - for accessing pre-generated demo data
  backendBaseUrl: string,        // Real backend URL for production
  environment: "development" | "production",
  cacheEnabled: boolean,         // Enable/disable caching (default: true)
  persistentCache: boolean,      // Enable localStorage persistence in browser (default: false)
  generateMode: "ai" | "faker" | "auto",  // Generation mode (default: "auto")
  fakerSeed: number,             // Seed for deterministic Faker.js generation (optional)
  regenerateOnConfigChange: boolean,  // Regenerate when endpoint config changes (default: true)

  // Collections configuration:
  collections: {
    branch: string,              // Branch name for data isolation (e.g., "main", "client-acme")
    persistence: {
      mode: "memory" | "local" | "cloud",  // Persistence strategy
      filePath: string,          // File path for Node.js file persistence (default: ".symulate-data.json")
    },
  },
});
```

## Generation Modes

Symulate supports three generation modes to fit different development scenarios:

### AI Mode (Realistic Data)
Best for development and prototyping with realistic, contextual data.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx",
  generateMode: "ai", // Always use AI - requires API key
});
```

**Use cases:**
- Frontend development with realistic data
- UI/UX prototyping
- Demos and presentations

### Faker Mode (CI/CD & Offline)
Pure Faker.js generation without network dependency. Perfect for CI/CD pipelines.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx", // Required (free tier = unlimited Faker)
  generateMode: "faker",
  fakerSeed: 12345,             // Optional: deterministic data for tests
});
```

**Use cases:**
- CI/CD pipelines (Jenkins, GitHub Actions)
- Integration tests
- Offline development (after initial API key setup)
- Air-gapped environments

**Benefits:**
- ‚úÖ No network calls during generation
- ‚úÖ **Unlimited on free tier**
- ‚úÖ Fast generation (<1ms)
- ‚úÖ Deterministic with seed (reproducible tests)

**Note:** API key required for all modes (including Faker) for user tracking and quota management. Free tier includes unlimited Faker.js mode.

### Auto Mode (Default - Best of Both)
Tries AI first, falls back to Faker.js if API key is missing or network fails.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx", // Optional
  generateMode: "auto", // Default mode
});
```

**Use cases:**
- Teams with mixed workflows
- Gradual adoption
- Offline-first development

## CI/CD Example

Use Faker mode in your test pipeline for fast, deterministic mocks:

```typescript
// jest.setup.ts or vitest.config.ts
import { configureSymulate } from "@symulate/sdk";

configureSymulate({
  symulateApiKey: process.env.Symulate_API_KEY, // Required (use free tier)
  generateMode: "faker",                       // No network calls
  fakerSeed: 12345,                            // Same data every test run
  environment: "development",
  cacheEnabled: true,
});
```

```yaml
# .github/workflows/test.yml
- name: Run tests
  run: npm test
  env:
    NODE_ENV: development
    Symulate_API_KEY: ${{ secrets.Symulate_API_KEY }} # Free tier = unlimited Faker
```

**Why API key is required:**
- ‚úÖ User tracking (helps us improve the product)
- ‚úÖ Quota management (prevents abuse)
- ‚úÖ **Free tier includes unlimited Faker.js mode** - perfect for CI/CD
- ‚úÖ No network calls are made in Faker mode (offline-safe)

### Getting Started

1. Sign up for a free account at [https://platform.symulate.dev](https://platform.symulate.dev)
2. Create an API key from your dashboard
3. Add the API key to your environment variables:
   ```bash
   Symulate_API_KEY=sym_live_your_api_key_here
   ```
4. Configure Symulate in your app (see Quick Start above)

## Schema Builder (`m`)

### Basic Types

```typescript
const schema = m.object({
  id: m.uuid(),
  text: m.string(),
  count: m.number(),
  active: m.boolean(),
  createdAt: m.date(),
  email: m.email(),
  website: m.url(),
  phone: m.phoneNumber(),
});
```

### Person Fields

```typescript
const person = m.object({
  fullName: m.person.fullName(),
  firstName: m.person.firstName(),
  lastName: m.person.lastName(),
  jobTitle: m.person.jobTitle(),
});
```

### Internet Fields

```typescript
const profile = m.object({
  userName: m.internet.userName(),
  avatar: m.internet.avatar(),
});
```

### Location Fields

```typescript
const address = m.object({
  street: m.location.street(),
  city: m.location.city(),
  state: m.location.state(),
  zipCode: m.location.zipCode(),
  country: m.location.country(),
  latitude: m.location.latitude(),
  longitude: m.location.longitude(),
});
```

### Commerce Fields

```typescript
const product = m.object({
  name: m.commerce.productName(),
  department: m.commerce.department(),
  price: m.commerce.price(),
});
```

### Lorem Fields

```typescript
const content = m.object({
  word: m.lorem.word(),
  sentence: m.lorem.sentence(),
  paragraph: m.lorem.paragraph(),
});
```

### Nested Objects

```typescript
const user = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  address: m.object({
    street: m.location.street(),
    city: m.location.city(),
  }),
});
```

### Arrays

```typescript
const article = m.object({
  id: m.uuid(),
  title: m.lorem.sentence(),
  tags: m.array(m.lorem.word()),
});
```

## Type Inference

Use `Infer<>` to extract TypeScript types from schemas:

```typescript
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.commerce.productName(),
  price: m.commerce.price(),
});

type Product = Infer<typeof ProductSchema>;
// { id: string; name: string; price: number }
```

## Mock Configuration

```typescript
mock: {
  count: 10, // Generate array of 10 items
  instruction: "Generate premium users with verified accounts", // Optional AI instruction
  delay: 500, // Simulate loading delay in milliseconds (only for cached data)
}
```

### Simulating Network Latency

The `delay` option allows you to simulate realistic network latency for cached mock data. This is useful for:
- Testing loading states and spinners
- Simulating slow network conditions
- Demonstrating progressive loading UIs
- E2E tests that expect async behavior

```typescript
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET",
  schema: UserSchema,
  mock: {
    count: 5,
    delay: 800, // Simulate 800ms network latency
  },
});

// Usage - will wait 800ms before returning cached data
const users = await getUsers(); // Takes ~800ms when cache hit
```

**Important Notes:**
- Delay only applies to **cached data** (cache hits)
- First request (cache miss) uses actual AI/Faker generation time
- Set `delay: 0` or omit it for instant responses
- Useful for testing loading states without slowing down development

### Contextual Metadata

The `metadata` option allows you to pass additional contextual information to the AI for more accurate mock data generation. Unlike `instruction` which provides natural language guidance, `metadata` provides structured data that the AI can use to generate more realistic, context-aware values.

```typescript
mock: {
  count: 10,
  instruction: "Generate employees from a tech company",
  metadata: {
    industry: "Technology",
    companySize: "500-1000",
    region: "North America",
    averageSalary: "$120,000",
    techStack: ["React", "Node.js", "PostgreSQL"]
  }
}
```

**Use Cases:**

**1. Domain-Specific Context**

```typescript
export const getProducts = defineEndpoint<Product[]>({
  path: "/api/products",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 20,
    instruction: "Generate e-commerce products",
    metadata: {
      productCategory: "Electronics",
      priceRange: { min: 50, max: 2000 },
      targetMarket: "Premium consumers",
      brand: "TechPro"
    }
  }
});
// AI will generate electronics products within the price range for the target market
```

**2. User Demographics**

```typescript
export const getCustomers = defineEndpoint<Customer[]>({
  path: "/api/customers",
  method: "GET",
  schema: CustomerSchema,
  mock: {
    count: 50,
    metadata: {
      ageRange: "25-45",
      location: "Urban areas in Germany",
      income: "Above average",
      interests: ["Technology", "Travel", "Sustainability"]
    }
  }
});
// Generates customers matching the demographic profile
```

**3. Business Context**

```typescript
export const getOrders = defineEndpoint<Order[]>({
  path: "/api/orders",
  method: "GET",
  schema: OrderSchema,
  mock: {
    count: 100,
    instruction: "Generate recent orders",
    metadata: {
      businessHours: "9am-5pm EST",
      peakSeason: "Q4",
      averageOrderValue: "$150",
      customerType: "B2B",
      paymentMethods: ["Invoice", "Corporate Credit Card"]
    }
  }
});
// Orders will reflect B2B patterns and payment methods
```

**4. Regional/Cultural Context**

```typescript
export const getRestaurants = defineEndpoint<Restaurant[]>({
  path: "/api/restaurants",
  method: "GET",
  schema: RestaurantSchema,
  mock: {
    count: 15,
    instruction: "Generate restaurant listings",
    metadata: {
      cuisine: "Japanese",
      priceLevel: "$$-$$$",
      city: "Berlin",
      culturalPreferences: "Authentic ingredients, Modern presentation"
    }
  }
});
// AI generates realistic Japanese restaurants appropriate for Berlin
```

**How It Works:**

1. **Structured Data**: Metadata is passed as a JSON object, allowing complex nested data
2. **AI Integration**: The AI uses metadata to inform every generated field, not just specific ones
3. **Cache Invalidation**: Different metadata values generate different cache keys
4. **Type Safety**: Use TypeScript to define metadata shapes for consistency

**Best Practices:**

```typescript
// Good - Specific, structured context
metadata: {
  industry: "Healthcare",
  complianceStandards: ["HIPAA", "GDPR"],
  dataClassification: "PHI",
  userRoles: ["Doctor", "Nurse", "Admin"]
}

// Avoid - Too vague or redundant with instruction
metadata: {
  type: "users",
  makeItRealistic: true
}
```

**Metadata vs Instruction:**
- **Instruction**: Natural language guidance on *what* to generate ("Generate premium users")
- **Metadata**: Structured context about *how* to generate it (industry, region, demographics)
- **Use both**: Combine for best results

```typescript
mock: {
  count: 100,
  instruction: "Generate active enterprise customers with recent purchases",
  metadata: {
    industry: "Manufacturing",
    companySize: "1000+",
    contractValue: "$50k-$500k/year",
    region: "EMEA",
    productCategories: ["Industrial Equipment", "Maintenance Supplies"]
  }
}
// Instruction guides overall theme, metadata provides specific constraints
```

## Stateful Collections (CRUD)

**NEW:** Define collections with full CRUD operations and persistent state management. Unlike basic endpoints that simulate responses, collections maintain state across requests with automatic pagination, filtering, and server-side persistence.

### Overview

Stateful Collections provide a complete backend-like experience during frontend development:

- ‚úÖ **Full CRUD Operations**: Create, Read, Update, Delete with type safety
- ‚úÖ **Server-Side Pagination**: True paginated responses (not client-side filtering)
- ‚úÖ **Persistent State**: Data persists across requests and page reloads
- ‚úÖ **Branch Isolation**: Multi-tenant data isolation for customer demos
- ‚úÖ **AI-Generated Seeds**: Automatically generate realistic seed data
- ‚úÖ **Read-After-Write Consistency**: Created/updated items are immediately available

### Quick Start

```typescript
import { defineCollection, m, type Infer } from '@symulate/sdk';

// Define schema
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.commerce.productName(),
  price: m.commerce.price(),
  inStock: m.boolean(),
  category: m.commerce.department(),
  createdAt: m.date(),
});

export type Product = Infer<typeof ProductSchema>;

// Define collection
export const products = defineCollection<Product>({
  name: 'products',
  basePath: '/api/products',
  schema: ProductSchema,
  seedCount: 20,  // Initial items to generate
  seedInstruction: 'Generate realistic e-commerce products',
});
```

### CRUD Operations

#### List with Pagination

```typescript
// Basic list
const response = await products.list();
console.log(response.data);        // Product[]
console.log(response.pagination);  // { page: 1, limit: 20, total: 20, totalPages: 1 }

// With pagination
const page2 = await products.list({ page: 2, limit: 10 });

// With sorting
const sorted = await products.list({
  sortBy: 'price',
  sortOrder: 'desc'
});

// With filtering
const filtered = await products.list({
  filter: { category: 'Electronics' }
});
```

#### Get Single Item

```typescript
const product = await products.get('product-id-123');
console.log(product.name);  // Fully typed!
```

#### Create Item

```typescript
const newProduct = await products.create({
  name: 'Wireless Mouse',
  price: 29.99,
  inStock: true,
  category: 'Electronics'
  // id, createdAt auto-generated
});

console.log(newProduct.id);  // Auto-generated UUID
```

#### Update Item (Partial)

```typescript
// Only update specified fields
const updated = await products.update('product-id-123', {
  price: 24.99,  // Only price changes
  inStock: false
});

// Other fields remain unchanged
console.log(updated.name);  // Original name preserved
```

#### Delete Item

```typescript
await products.delete('product-id-123');

// Item is permanently removed
const response = await products.list();
// product-id-123 no longer in the list
```

### Collection Configuration

```typescript
defineCollection<T>({
  name: string,              // Collection identifier (required)
  basePath: string,          // Base API path (required)
  schema: BaseSchema<T>,     // Data schema (required)
  seedCount?: number,        // Initial items to generate (default: 20)
  seedInstruction?: string,  // AI instruction for seed data
  operations?: {             // Enable/disable operations
    list?: boolean,          // Default: true
    get?: boolean,           // Default: true
    create?: boolean,        // Default: true
    update?: boolean,        // Default: true
    delete?: boolean,        // Default: true
  },
})
```

### Branch Isolation

Collections support branch isolation for multi-tenant demos and testing environments:

```typescript
// Configure branch in global config
configureSymulate({
  collections: {
    branch: 'customer-acme'  // Isolate data per customer/environment
  }
});

// All collection operations now use 'customer-acme' branch
await products.list();   // Only returns products from 'customer-acme' branch
await products.create(); // Creates product in 'customer-acme' branch
```

**Use Cases:**
- **Customer Demos**: Separate data for each customer demo
  ```typescript
  // Demo for customer A
  configureSymulate({ collections: { branch: 'demo-customer-a' } });

  // Demo for customer B
  configureSymulate({ collections: { branch: 'demo-customer-b' } });
  ```

- **Environment Separation**: Isolate dev/staging/production data
  ```typescript
  const branch = process.env.NODE_ENV === 'production' ? 'main' : 'dev';
  configureSymulate({ collections: { branch } });
  ```

### Persistence Modes

Collections support three persistence modes for different use cases:

```typescript
configureSymulate({
  collections: {
    persistence: {
      mode: 'local'  // 'memory', 'local', or 'cloud'
    }
  }
});
```

**Persistence Modes:**

- **`memory`** (default): In-memory only
  - ‚úÖ Fastest performance
  - ‚úÖ Perfect for quick prototyping
  - ‚ùå Data lost on page refresh
  - **Use for**: Quick tests, demos where clean state is desired

- **`local`**: localStorage (browser) or filesystem (Node.js)
  - ‚úÖ Data survives page refreshes
  - ‚úÖ No backend required
  - ‚úÖ Works in both browser and Node.js
  - ‚ö†Ô∏è ~5-10MB browser storage limit
  - **Browser**: Uses `localStorage` API
  - **Node.js**: Saves to `.symulate-data.json` file
  - **Use for**: Local development, offline testing, prototypes

- **`cloud`**: Server-side persistence via Supabase
  - ‚úÖ True server-side state
  - ‚úÖ Multi-tenant with branch isolation
  - ‚úÖ Shared across devices/sessions
  - ‚úÖ Server-side pagination
  - **Requires**: Symulate API key and project ID
  - **Use for**: Realistic backend simulation, customer demos, team collaboration

**Example Configuration:**

```typescript
// Local development with browser persistence
configureSymulate({
  collections: {
    persistence: {
      mode: 'local'  // Survives page refresh
    }
  }
});

// Production-like with cloud persistence
configureSymulate({
  symulateApiKey: 'sym_live_xxx',
  projectId: 'proj_xxx',
  collections: {
    persistence: {
      mode: 'cloud'  // Server-side with branch isolation
    },
    branch: 'customer-acme'
  }
});
```

### CLI Management

Manage collections via CLI commands:

```bash
# List all collections
npx symulate collections list
npx symulate collections list -b customer-acme

# Delete collections
npx symulate collections delete -n products
npx symulate collections delete -n products -b dev
npx symulate collections delete --all  # With confirmation

# Pre-generate all collections
npx symulate collections pregenerate

# Pre-generate for specific branch
npx symulate collections pregenerate -b demo
```

### Query Parameter Customization

Customize query parameter names and routing for pagination, sorting, and filtering to match your backend API conventions.

#### Default Behavior

By default, collections automatically add these query parameters to list operations:
- **Pagination**: `page`, `limit`
- **Sorting**: `sortBy`, `sortOrder`
- **Filtering**: `filter`

```typescript
// These work out of the box
await products.list({ page: 1, limit: 20, sortBy: 'price', sortOrder: 'desc' });
// GET /api/products?page=1&limit=20&sortBy=price&sortOrder=desc
```

#### Role-Based Parameter Customization

Use the `params` array with semantic roles to customize parameter names and routing:

```typescript
defineCollection({
  name: 'products',
  basePath: '/api/products',
  schema: ProductSchema,
  operations: {
    list: {
      params: [
        // Custom pagination parameter names
        { name: 'pageNumber', location: 'query', role: 'pagination.page', schema: m.number() },
        { name: 'pageSize', location: 'query', role: 'pagination.limit', schema: m.number() },

        // Custom sorting parameter names
        { name: 'orderBy', location: 'query', role: 'sort.field', schema: m.string() },
        { name: 'direction', location: 'query', role: 'sort.order', schema: m.string() },

        // Custom filter parameter name
        { name: 'search', location: 'query', role: 'filter', schema: m.object({ category: m.string() }) },
      ]
    }
  }
});

// Internal API stays the same
await products.list({ page: 1, limit: 20, sortBy: 'price', sortOrder: 'desc' });

// But generates URL with custom parameter names:
// GET /api/products?pageNumber=1&pageSize=20&orderBy=price&direction=desc
```

#### Available Parameter Roles

| Role | Purpose | Default Name |
|------|---------|--------------|
| `pagination.page` | Current page number | `page` |
| `pagination.limit` | Items per page | `limit` |
| `sort.field` | Field to sort by | `sortBy` |
| `sort.order` | Sort direction (asc/desc) | `sortOrder` |
| `filter` | Filter criteria | `filter` |

#### Parameter Locations

Control WHERE parameters are sent using the `location` property:

```typescript
defineCollection({
  name: 'products',
  operations: {
    list: {
      params: [
        // Send in query string (default)
        { name: 'page', location: 'query', role: 'pagination.page', schema: m.number() },

        // Send in request body (switches to POST)
        { name: 'filter', location: 'body', role: 'filter', schema: m.object({ category: m.string() }) },

        // Send as HTTP header
        { name: 'X-Sort-By', location: 'header', role: 'sort.field', schema: m.string() },
      ]
    }
  }
});

// Usage
await products.list({ page: 1, filter: { category: 'Electronics' }, sortBy: 'price' });
// POST /api/products?page=1
// Headers: X-Sort-By: price
// Body: { "filter": { "category": "Electronics" } }
```

**Available locations:**
- **`query`** (default) - URL query string parameter
- **`body`** - Request body (automatically switches to POST)
- **`header`** - HTTP header

**Important Notes:**
- When any parameter uses `location: 'body'`, the request method automatically changes from GET to POST
- You can mix different locations in the same request (query + body + headers)
- Header names can be custom (e.g., `X-Page`, `X-Sort-By`)

#### Disabling Query Parameters

You can disable automatic query parameters globally or per-operation:

**Global disable:**
```typescript
configureSymulate({
  collections: {
    disableQueryParams: true  // Disables for ALL collections
  }
});

// No query parameters added
await products.list({ page: 1, limit: 20 });
// GET /api/products (no query params)
```

**Per-operation disable:**
```typescript
defineCollection({
  name: 'products',
  operations: {
    list: {
      disableQueryParams: true  // Disables only for this operation
    }
  }
});
```

#### Common API Conventions

**Laravel/Spring Boot style:**
```typescript
params: [
  { name: 'page', location: 'query', role: 'pagination.page', schema: m.number() },
  { name: 'per_page', location: 'query', role: 'pagination.limit', schema: m.number() },
  { name: 'sort', location: 'query', role: 'sort.field', schema: m.string() },
  { name: 'order', location: 'query', role: 'sort.order', schema: m.string() },
]
```

**ASP.NET Core style:**
```typescript
params: [
  { name: 'pageNumber', location: 'query', role: 'pagination.page', schema: m.number() },
  { name: 'pageSize', location: 'query', role: 'pagination.limit', schema: m.number() },
  { name: 'orderBy', location: 'query', role: 'sort.field', schema: m.string() },
  { name: 'sortOrder', location: 'query', role: 'sort.order', schema: m.string() },
]
```

**Django style:**
```typescript
params: [
  { name: 'page', location: 'query', role: 'pagination.page', schema: m.number() },
  { name: 'page_size', location: 'query', role: 'pagination.limit', schema: m.number() },
  { name: 'ordering', location: 'query', role: 'sort.field', schema: m.string() },
  { name: 'search', location: 'query', role: 'filter', schema: m.string() },
]
```

### Flexible Response Schemas

Customize the response structure of list operations using `responseSchema` with meta fields and aggregates.

#### Default Response Structure

By default, list operations return:

```typescript
{
  data: T[],           // Paginated items
  pagination: {
    page: number,      // Current page
    limit: number,     // Items per page
    total: number,     // Total items count
    totalPages: number // Total pages
  }
}
```

#### Custom Response Structure

Define any response structure you want using `collectionsMeta` fields:

```typescript
const products = defineCollection({
  name: 'products',
  basePath: '/api/products',
  schema: ProductSchema,
  operations: {
    list: {
      responseSchema: m.object({
        items: [ProductSchema],  // Array location for paginated data
        currentPage: m.collectionsMeta.page(),
        pageSize: m.collectionsMeta.limit(),
        totalItems: m.collectionsMeta.total(),
        totalPages: m.collectionsMeta.totalPages(),
      }),
    },
  },
});

// Returns:
// {
//   items: Product[],
//   currentPage: 1,
//   pageSize: 20,
//   totalItems: 100,
//   totalPages: 5
// }
```

#### Available Meta Fields

**Basic Fields:**
- `m.collectionsMeta.page()` - Current page number
- `m.collectionsMeta.limit()` - Items per page
- `m.collectionsMeta.total()` - Total items count
- `m.collectionsMeta.totalPages()` - Total pages

**Aggregate Fields:**
- `m.collectionsMeta.avg("fieldName")` - Average of numeric field
- `m.collectionsMeta.sum("fieldName")` - Sum of numeric field
- `m.collectionsMeta.min("fieldName")` - Minimum value
- `m.collectionsMeta.max("fieldName")` - Maximum value
- `m.collectionsMeta.count("fieldName", value)` - Count where field equals value

#### Response with Aggregates

Include statistics and analytics in your response:

```typescript
const products = defineCollection({
  name: 'products',
  schema: ProductSchema,
  operations: {
    list: {
      responseSchema: m.object({
        products: [ProductSchema],
        meta: m.object({
          page: m.collectionsMeta.page(),
          total: m.collectionsMeta.total(),
        }),
        stats: m.object({
          averagePrice: m.collectionsMeta.avg("price"),
          totalViews: m.collectionsMeta.sum("views"),
          minPrice: m.collectionsMeta.min("price"),
          maxPrice: m.collectionsMeta.max("price"),
          averageRating: m.collectionsMeta.avg("rating"),
          inStockCount: m.collectionsMeta.count("inStock", true),
          outOfStockCount: m.collectionsMeta.count("inStock", false),
        }),
      }),
    },
  },
});

// Returns:
// {
//   products: [...],
//   meta: { page: 1, total: 50 },
//   stats: {
//     averagePrice: 249.99,
//     totalViews: 15420,
//     minPrice: 29.99,
//     maxPrice: 999.99,
//     averageRating: 4.3,
//     inStockCount: 42,
//     outOfStockCount: 8
//   }
// }
```

#### Nested Structures

Create complex nested response structures:

```typescript
responseSchema: m.object({
  result: m.object({
    data: [ProductSchema],
    pagination: m.object({
      current: m.collectionsMeta.page(),
      total: m.collectionsMeta.totalPages(),
    }),
  }),
  analytics: m.object({
    pricing: m.object({
      average: m.collectionsMeta.avg("price"),
      range: m.object({
        min: m.collectionsMeta.min("price"),
        max: m.collectionsMeta.max("price"),
      }),
    }),
    inventory: m.object({
      available: m.collectionsMeta.count("inStock", true),
      total: m.collectionsMeta.total(),
    }),
  }),
})
```

**Key Points:**
- Arrays `[Schema]` mark where paginated items are placed
- Aggregates calculate over all items (before pagination)
- Count aggregates can filter by field value
- Structure can be arbitrarily nested
- Works with both local and cloud persistence

### Server-Side vs Client-Side

**Traditional Endpoints** (defineEndpoint):
- Simulated responses
- No state persistence
- Client-side pagination (all data loaded)
- Static mock data

**Stateful Collections** (defineCollection):
- Full CRUD operations
- Server-side persistence
- True pagination (only requested page returned)
- Dynamic state changes

### Complete Example

```typescript
import { defineCollection, m, type Infer, configureSymulate } from '@symulate/sdk';

// Configure with branch support
configureSymulate({
  symulateApiKey: 'sym_live_xxx',
  projectId: 'proj_xxx',
  environment: 'development',
  collections: {
    branch: 'main'  // or 'demo-customer-a', 'dev', etc.
  }
});

// Define user collection
const UserSchema = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  email: m.email(),
  role: m.string("Role: admin, user, or guest"),
  createdAt: m.date(),
  updatedAt: m.date(),
});

export type User = Infer<typeof UserSchema>;

export const users = defineCollection<User>({
  name: 'users',
  basePath: '/api/users',
  schema: UserSchema,
  seedCount: 50,
  seedInstruction: 'Generate diverse tech company employees',
});

// Usage in your app
async function userManagement() {
  // List users with pagination
  const page1 = await users.list({ page: 1, limit: 10 });
  console.log(`Total users: ${page1.pagination.total}`);

  // Create new user
  const newUser = await users.create({
    name: 'Jane Doe',
    email: 'jane@example.com',
    role: 'admin'
  });

  // Get user by ID
  const user = await users.get(newUser.id);

  // Update user
  const updated = await users.update(user.id, {
    role: 'user'  // Demote from admin to user
  });

  // Delete user
  await users.delete(user.id);

  // Verify deletion
  const page2 = await users.list();
  console.log(`Remaining users: ${page2.pagination.total}`);
}
```

### Collection Metadata & Aggregates

Use `m.collectionsMeta` to include pagination metadata and aggregate functions in your response schemas. These fields are automatically calculated and populated by the server.

#### Pagination Metadata

Include pagination information in your list operation responses:

```typescript
const ListResponseSchema = m.object({
  data: m.array(ProductSchema),
  pagination: m.object({
    page: m.collectionsMeta.page(),
    limit: m.collectionsMeta.limit(),
    total: m.collectionsMeta.total(),
    totalPages: m.collectionsMeta.totalPages(),
  }),
});

export const products = defineCollection({
  name: 'products',
  schema: ProductSchema,
  operations: {
    list: {
      responseSchema: ListResponseSchema
    }
  }
});

// Response automatically includes pagination metadata
const response = await products.list({ page: 2, limit: 20 });
console.log(response.pagination);
// {
//   page: 2,
//   limit: 20,
//   total: 150,
//   totalPages: 8
// }
```

#### Aggregate Functions

Calculate statistics across **all items** in the collection (not just the current page):

**Available Aggregates:**
- `m.collectionsMeta.avg(fieldName)` - Average value
- `m.collectionsMeta.sum(fieldName)` - Sum of all values
- `m.collectionsMeta.min(fieldName)` - Minimum value
- `m.collectionsMeta.max(fieldName)` - Maximum value
- `m.collectionsMeta.count(fieldName, value)` - Count items matching value

```typescript
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.string(),
  price: m.number(),
  category: m.string(),
  inStock: m.boolean(),
});

const ProductStatsSchema = m.object({
  data: m.array(ProductSchema),
  pagination: m.object({
    page: m.collectionsMeta.page(),
    limit: m.collectionsMeta.limit(),
    total: m.collectionsMeta.total(),
    totalPages: m.collectionsMeta.totalPages(),
  }),
  stats: m.object({
    averagePrice: m.collectionsMeta.avg("price"),
    totalValue: m.collectionsMeta.sum("price"),
    cheapest: m.collectionsMeta.min("price"),
    mostExpensive: m.collectionsMeta.max("price"),
    inStockCount: m.collectionsMeta.count("inStock", true),
  }),
});

export const products = defineCollection({
  name: 'products',
  schema: ProductSchema,
  seedCount: 100,
  operations: {
    list: {
      responseSchema: ProductStatsSchema
    }
  }
});

// Aggregates calculated across ALL 100 products, not just current page
const response = await products.list({ page: 1, limit: 10 });
console.log(response.stats);
// {
//   averagePrice: 89.99,
//   totalValue: 8999.00,
//   cheapest: 9.99,
//   mostExpensive: 499.99,
//   inStockCount: 67
// }
```

#### Advanced Example

Combine metadata and aggregates for powerful analytics:

```typescript
const OrderSchema = m.object({
  id: m.uuid(),
  customerId: m.string(),
  total: m.number(),
  status: m.string("pending, processing, completed, cancelled"),
  createdAt: m.date(),
});

const OrderAnalyticsSchema = m.object({
  orders: m.array(OrderSchema),
  pagination: m.object({
    page: m.collectionsMeta.page(),
    limit: m.collectionsMeta.limit(),
    total: m.collectionsMeta.total(),
    totalPages: m.collectionsMeta.totalPages(),
  }),
  analytics: m.object({
    // Revenue metrics
    totalRevenue: m.collectionsMeta.sum("total"),
    averageOrderValue: m.collectionsMeta.avg("total"),
    largestOrder: m.collectionsMeta.max("total"),

    // Order status counts
    completedOrders: m.collectionsMeta.count("status", "completed"),
    pendingOrders: m.collectionsMeta.count("status", "pending"),
    cancelledOrders: m.collectionsMeta.count("status", "cancelled"),
  }),
});

export const orders = defineCollection({
  name: 'orders',
  schema: OrderSchema,
  seedCount: 500,
  operations: {
    list: {
      responseSchema: OrderAnalyticsSchema
    }
  }
});

// Get page 1 with complete analytics
const dashboard = await orders.list({ page: 1, limit: 25 });

console.log(`Showing ${dashboard.orders.length} of ${dashboard.pagination.total} orders`);
console.log(`Total Revenue: $${dashboard.analytics.totalRevenue.toFixed(2)}`);
console.log(`Average Order: $${dashboard.analytics.averageOrderValue.toFixed(2)}`);
console.log(`Completed: ${dashboard.analytics.completedOrders}`);
console.log(`Pending: ${dashboard.analytics.pendingOrders}`);
```

**Key Features:**
- ‚úÖ Aggregates calculated across **entire collection**, not just current page
- ‚úÖ Automatically updated when items are created/updated/deleted
- ‚úÖ Works with all persistence modes (memory, local, cloud)
- ‚úÖ Zero configuration - just add to your schema
- ‚úÖ Type-safe with full TypeScript inference

**Common Use Cases:**
- Dashboard statistics (total users, revenue, etc.)
- E-commerce analytics (average price, inventory counts)
- Reporting endpoints (aggregate data across large datasets)
- Admin panels (totals, averages, status counts)

## Tenant Demos (Pre-Generated Demo Data)

**NEW:** Create isolated demo environments with pre-generated AI data for customer demos, sales presentations, and live testing without impacting development data.

### Overview

Tenant Demos provide a powerful way to create realistic, production-like demo environments:

- ‚úÖ **Pre-Generated Data**: AI generates all data before your demo
- ‚úÖ **Isolated Environments**: Each demo has its own data that never changes
- ‚úÖ **Custom Instructions**: AI instructions for domain-specific data
- ‚úÖ **Selectable Content**: Choose which collections/endpoints to generate
- ‚úÖ **Instant API Access**: Demo API key for immediate SDK integration
- ‚úÖ **Expiration Control**: Optional expiration dates for time-limited demos

### Why Use Tenant Demos?

**Traditional Mock Data Problems:**
- üî¥ Data regenerates on each request (inconsistent)
- üî¥ Uses AI tokens during live demos
- üî¥ Latency from real-time generation
- üî¥ Same data for all customers/demos

**Tenant Demos Solution:**
- ‚úÖ Pre-generated, consistent data
- ‚úÖ Zero AI tokens during demos
- ‚úÖ Instant response times
- ‚úÖ Custom data per customer/demo
- ‚úÖ Production-realistic experience

### Creating a Demo

1. **Create Demo in Platform UI**
   - Navigate to Dashboard ‚Üí Demos
   - Click "Create Demo"
   - Enter name (e.g., "Acme Corp Demo", "Q1 Sales Presentation")
   - Optional: Set expiration date

2. **Configure Data Generation**
   ```
   General Instruction (applies to all):
   "Generate data for a Berlin-based e-commerce company selling electronics"

   Collections:
   ‚òë products (Custom: "Focus on laptops and smartphones")
   ‚òë users (Custom: "B2B customers in automotive industry")

   Endpoints:
   ‚òë GET /api/stats (Custom: "Show 25% year-over-year growth")
   ‚òë GET /api/dashboard (Custom: "Premium tier analytics")
   ```

3. **Generate Data**
   - Click "Generate Data"
   - AI processes all selections in background
   - Receive email when complete
   - View progress in Jobs tab

4. **Get Demo API Key**
   - Click "View API Key" on your demo
   - Copy key (format: `sym_demo_xxx`)
   - Key never expires unless demo is deleted

### Using Demo Data in Your App

```typescript
import { configureSymulate } from '@symulate/sdk';

// Configure SDK with demo API key
configureSymulate({
  demoApiKey: 'sym_demo_your_key_here', // Routes ALL calls to pre-generated data
  projectId: 'proj_xxx',
  backendBaseUrl: "https://api.myapp.com", // Not used when demoApiKey is set
});

// All endpoint and collection calls now use pre-generated demo data
const products = await getProducts();       // ‚úì Pre-generated products
const users = await userCollection.list();  // ‚úì Pre-generated users
const stats = await getStats();            // ‚úì Pre-generated stats

// CRUD operations on collections still work!
const newProduct = await productCollection.create({ name: "New Item" });
// Creates in demo data (isolated from other demos)
```

### Demo API Key Behavior

When `demoApiKey` is configured:
- **Collections**: All CRUD operations use demo data
  - `list()` - Returns pre-generated items
  - `get()` - Fetches from demo data
  - `create()` - Adds to demo data
  - `update()` - Modifies demo data
  - `delete()` - Removes from demo data

- **Regular Endpoints**: All calls return pre-generated responses
  - No real-time AI generation
  - No network calls to backend
  - Instant responses

### Use Cases

**1. Customer Demos**
```typescript
// Demo for automotive client
configureSymulate({
  demoApiKey: 'sym_demo_automotive_xyz',
});
// Shows automotive-specific data with custom branding
```

**2. Sales Presentations**
```typescript
// Different data for each prospect
// Demo A: E-commerce retailer
configureSymulate({ demoApiKey: 'sym_demo_retailer_abc' });

// Demo B: Healthcare provider
configureSymulate({ demoApiKey: 'sym_demo_healthcare_def' });
```

**3. Trade Shows**
```typescript
// Pre-loaded demo that works without internet
configureSymulate({
  demoApiKey: 'sym_demo_tradeshow_2024',
  // All data pre-generated, works offline
});
```

**4. Onboarding & Training**
```typescript
// Safe environment for new users to practice
configureSymulate({
  demoApiKey: 'sym_demo_training_env',
  // Users can create/edit/delete without affecting real data
});
```

### Custom Instructions

**General Instruction** (applies to all data):
```
"Generate data for a Berlin-based company in the automotive industry"
```

**Collection-Specific Instructions**:
```
Products: "Focus on car parts and accessories"
Users: "B2B customers, primarily German automotive manufacturers"
```

**Endpoint-Specific Instructions**:
```
GET /api/dashboard: "Show strong Q4 performance with 30% growth"
GET /api/stats: "Display metrics for 500+ active customers"
```

### Re-Triggering Generation

Need fresh data? Re-trigger generation from the Platform UI:
1. Go to Dashboard ‚Üí Demos ‚Üí Jobs tab
2. Find your completed job
3. Click the refresh icon
4. New data is generated with same configuration

### Best Practices

**1. Descriptive Names**
```typescript
// Good
"Acme Corp Demo - Q1 2024"
"Healthcare Client Presentation - Dr. Smith"

// Avoid
"Demo 1"
"Test"
```

**2. Industry-Specific Instructions**
```typescript
// Good - Very specific
"Generate healthcare data compliant with HIPAA.
 Focus on patient records for cardiology department.
 Use realistic German names and Berlin addresses."

// Avoid - Too vague
"Generate some healthcare data"
```

**3. Demo Lifecycle Management**
```typescript
// Set expiration for temporary demos
Expiration: 2024-03-31 (demo for Q1 event)

// No expiration for permanent environments
Expiration: None (ongoing training environment)
```

**4. Multiple Demos for Different Audiences**
```
- demo-enterprise-clients (B2B features highlighted)
- demo-small-business (SMB-focused features)
- demo-internal-training (all features, test data)
```

### Limitations

- **Static after generation**: Data doesn't update unless you re-trigger
- **No real backend**: Mutations only affect demo data, not production
- **No validation**: Pre-generated data bypasses real API validation
- **Token usage**: Uses AI tokens during generation (but not during demos)

### Complete Example

```typescript
// 1. Create demo in platform UI
// Name: "Acme Corp Demo"
// General: "Fortune 500 manufacturing company in Detroit"
// Collections: products ‚úì, users ‚úì, orders ‚úì
// Endpoints: GET /api/dashboard ‚úì

// 2. Generate data (background job)
// 3. Copy demo API key: sym_demo_acme_xyz

// 4. Configure your app
import { configureSymulate, defineEndpoint, defineCollection, m } from '@symulate/sdk';

configureSymulate({
  demoApiKey: 'sym_demo_acme_xyz',
  projectId: 'proj_abc',
});

// Define your endpoints/collections as normal
const products = defineCollection({
  name: 'products',
  basePath: '/api/products',
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    price: m.number(),
  }),
});

const getDashboard = defineEndpoint({
  path: '/api/dashboard',
  method: 'GET',
  schema: m.object({
    revenue: m.number(),
    customers: m.number(),
    growth: m.number(),
  }),
});

// 5. Use in your app - all data is pre-generated
async function runDemo() {
  // Returns pre-generated products for Acme Corp
  const { data } = await products.list();
  console.log(`Showing ${data.length} products for demo`);

  // Returns pre-generated dashboard showing strong performance
  const dashboard = await getDashboard();
  console.log(`Revenue: $${dashboard.revenue.toLocaleString()}`);
  console.log(`Growth: ${dashboard.growth}%`);

  // CRUD operations work on demo data
  const newProduct = await products.create({
    name: "Custom Demo Product",
    price: 99.99
  });

  console.log(`Created: ${newProduct.name}`);
}

runDemo();
```

### Runtime Metadata

You can pass metadata dynamically at runtime when calling an endpoint, allowing context-specific data generation based on user input, component state, or application context.

**Basic Usage:**

```typescript
export const getEmployees = defineEndpoint<Employee[]>({
  path: '/api/employees',
  method: 'GET',
  schema: EmployeeSchema,
  mock: {
    count: 50,
    instruction: "Generate employees from a tech company"
  }
});

// Pass metadata at call time
const employees = await getEmployees({
  metadata: {
    industry: "Healthcare",
    companySize: "100-500",
    region: "APAC"
  }
});
```

**Merging Behavior:**

Runtime metadata is merged with configured metadata, with runtime values taking precedence:

```typescript
export const getProducts = defineEndpoint<Product[]>({
  path: '/api/products',
  method: 'GET',
  schema: ProductSchema,
  mock: {
    count: 20,
    metadata: {
      category: "Electronics",
      brand: "TechPro",
      priceRange: { min: 50, max: 500 }
    }
  }
});

// Override brand, keep category and priceRange, add new field
const products = await getProducts({
  metadata: {
    brand: "SuperTech",  // Overrides configured brand
    targetMarket: "Budget consumers"  // Adds new context
  }
});
// Merged metadata:
// {
//   category: "Electronics",      ‚Üê From config
//   brand: "SuperTech",           ‚Üê Overridden at runtime
//   priceRange: { min: 50, ... }, ‚Üê From config
//   targetMarket: "Budget..."     ‚Üê Added at runtime
// }
```

**Use Cases:**

1. **User-Driven Context**
```typescript
const getRecommendations = defineEndpoint<Product[]>({
  path: '/api/recommendations',
  method: 'GET',
  schema: ProductSchema,
  mock: { count: 10 }
});

// Adapt to user preferences
const recommendations = await getRecommendations({
  metadata: {
    userAge: user.age,
    userInterests: user.interests,
    pricePreference: user.budget,
    location: user.location
  }
});
```

2. **Dynamic Filters**
```typescript
const searchResults = await searchProducts({
  query: searchQuery,
  metadata: {
    category: selectedCategory,
    priceRange: priceFilter,
    inStock: showInStockOnly,
    sortBy: sortOption
  }
});
```

3. **A/B Testing**
```typescript
const users = await getUsers({
  metadata: {
    experiment: "variant_b",
    cohort: "premium_users",
    featureFlags: ["new_ui", "advanced_search"]
  }
});
```

4. **Localization**
```typescript
const content = await getContent({
  metadata: {
    language: currentLocale,
    region: userRegion,
    currency: preferredCurrency,
    dateFormat: localeDateFormat
  }
});
```

**Important Notes:**

- Metadata is NOT sent to your backend in production mode - it's only used for mock data generation
- Runtime metadata does not require parameter definitions - it's automatically excluded from validation
- Empty metadata objects (`metadata: {}`) are handled gracefully
- Nested objects and arrays are fully supported in runtime metadata

## Parameters

Define typed parameters for your endpoints with automatic validation and proper routing in both mock and production modes.

### Basic Usage

```typescript
const getUserById = defineEndpoint({
  path: "/api/users/:id",
  method: "GET",
  params: [
    {
      name: "id",
      location: "path",
      required: true,
      schema: m.uuid(),
      description: "The unique identifier of the user",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
});

// Usage - parameters are validated
const user = await getUserById({ id: "123e4567-e89b-12d3-a456-426614174000" });
```

### Parameter Locations

Parameters can be defined in four locations:

| Location | Description | Example |
|----------|-------------|---------|
| `path` | URL path segments | `/users/:id` |
| `query` | Query string parameters | `?page=1&limit=10` |
| `header` | HTTP headers | `Authorization: Bearer token` |
| `body` | Request body (POST/PUT/PATCH) | `{ name: "John" }` |

### Query Parameters

```typescript
const listUsers = defineEndpoint({
  path: "/api/users",
  method: "GET",
  params: [
    {
      name: "page",
      location: "query",
      required: false,
      schema: m.number(),
      description: "Page number for pagination",
      example: 1,
    },
    {
      name: "limit",
      location: "query",
      required: false,
      schema: m.number(),
      description: "Number of items per page",
      example: 10,
    },
    {
      name: "search",
      location: "query",
      required: false,
      schema: m.string(),
      description: "Search term to filter users",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  mock: { count: 10 },
});

// Usage
const users = await listUsers({ page: 1, limit: 20, search: "john" });
```

### Header Parameters

```typescript
const getProtectedData = defineEndpoint({
  path: "/api/protected/data",
  method: "GET",
  params: [
    {
      name: "Authorization",
      location: "header",
      required: true,
      schema: m.string(),
      description: "Bearer token for authentication",
    },
    {
      name: "X-API-Key",
      location: "header",
      required: false,
      schema: m.string(),
      description: "Optional API key",
    },
  ],
  schema: m.object({
    data: m.string(),
  }),
});

// Usage
const data = await getProtectedData({
  Authorization: "Bearer your-token",
  "X-API-Key": "optional-key",
});
```

### Mixed Parameters

Combine different parameter types:

```typescript
const createOffer = defineEndpoint({
  path: "/api/organizations/:orgId/offers",
  method: "POST",
  params: [
    // Path parameter
    {
      name: "orgId",
      location: "path",
      required: true,
      schema: m.uuid(),
      description: "Organization ID",
    },
    // Query parameters
    {
      name: "notify",
      location: "query",
      required: false,
      schema: m.boolean(),
      description: "Send notification email",
      example: true,
    },
    // Header parameter
    {
      name: "Authorization",
      location: "header",
      required: true,
      schema: m.string(),
      description: "Authentication token",
    },
    // Body parameters
    {
      name: "customer_name",
      location: "body",
      required: true,
      schema: m.string(),
      description: "Customer name",
    },
    {
      name: "amount",
      location: "body",
      required: true,
      schema: m.number(),
      description: "Offer amount",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    customer_name: m.string(),
    amount: m.number(),
    status: m.string(),
  }),
});

// Usage
const offer = await createOffer({
  orgId: "org-123",
  notify: true,
  Authorization: "Bearer token",
  customer_name: "Acme Corp",
  amount: 5000,
});

// In production mode, this produces:
// POST /api/organizations/org-123/offers?notify=true
// Headers:
//   Authorization: Bearer token
// Body:
//   { "customer_name": "Acme Corp", "amount": 5000 }
```

### Parameter Validation

Required parameters are validated at runtime:

```typescript
const searchProducts = defineEndpoint({
  path: "/api/products/search",
  method: "GET",
  params: [
    {
      name: "q",
      location: "query",
      required: true, // Required!
      schema: m.string(),
      description: "Search query",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
  }),
});

// This works
await searchProducts({ q: "laptop" });

// This throws an error
await searchProducts({ category: "electronics" });
// Error: [Symulate] Missing required parameters for GET /api/products/search: q (query)
```

### Production Mode Behavior

In production mode, parameters are routed correctly:

- **Path parameters** ‚Üí URL path replacement
- **Query parameters** ‚Üí Query string (`?key=value`)
- **Header parameters** ‚Üí HTTP headers
- **Body parameters** ‚Üí JSON request body

This ensures your endpoints work identically in both mock and production modes.

### Per-Endpoint Mode Override

You can override the global environment setting for specific endpoints using the `mode` parameter. This is useful when you want to test specific mock endpoints in a production application, or use real backend data for certain endpoints during development.

```typescript
// Global config set to production
configureSymulate({
  environment: "production",
  backendBaseUrl: "https://api.myapp.com",
});

// This endpoint uses mock data even though global env is production
export const getNewFeature = defineEndpoint({
  path: "/api/new-feature",
  method: "GET",
  mode: "mock", // Force mock mode for this endpoint
  schema: m.object({
    featureName: m.string(),
    enabled: m.boolean(),
  }),
});

// This endpoint uses production backend (respects global config)
export const getExistingData = defineEndpoint({
  path: "/api/existing-data",
  method: "GET",
  // No mode specified - uses global environment setting
  schema: m.object({
    data: m.string(),
  }),
});

// This endpoint forces production backend even in development
export const getCriticalData = defineEndpoint({
  path: "/api/critical-data",
  method: "GET",
  mode: "production", // Force production mode
  schema: m.object({
    balance: m.number(),
  }),
});
```

**Use cases:**
- **Testing new features in production apps**: Set global env to `production`, but use `mode: "mock"` for new feature endpoints you're still developing
- **Mix real and mock data**: Use real backend for stable features, mock data for features under development
- **Critical data in development**: Force certain endpoints to always use production backend (e.g., payment data, user balances)
- **Integration testing**: Test how your app behaves with a mix of real and mock APIs

**Mode options:**
- `mode: "mock"` - Always generate mock data (AI or Faker based on `generateMode`)
- `mode: "production"` - Always call the real backend API
- No mode specified - Falls back to global `environment` setting

## Caching Strategies

### Browser (default)
In-memory cache (clears on page reload):
```typescript
configureSymulate({ cacheEnabled: true });
```

### Browser (persistent)
localStorage cache (persists across reloads):
```typescript
configureSymulate({
  cacheEnabled: true,
  persistentCache: true,
});
```

### Node.js
File-based cache (`.Symulate-cache.json`) - automatic

### Cache Invalidation on Config Changes

By default, Symulate regenerates mock data when your endpoint configuration changes (e.g., changing the HTTP method, mock count, or mock instruction). This ensures your mocked data always matches your current configuration.

```typescript
// Default behavior - cache invalidates when config changes
configureSymulate({
  regenerateOnConfigChange: true, // default
});

// Example: Changing the endpoint config will trigger regeneration
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET", // If you change this to "POST", cache invalidates
  schema: UserSchema,
  mock: {
    count: 5, // If you change this to 10, cache invalidates
    instruction: "Generate users from tech companies", // Changing this invalidates cache
  },
});
```

**Disable config-based invalidation:**
```typescript
// Cache only invalidates on schema changes, not config changes
configureSymulate({
  regenerateOnConfigChange: false,
});
```

**What triggers cache invalidation:**
- When `regenerateOnConfigChange: true` (default):
  - Schema structure changes
  - HTTP method changes
  - Mock count changes
  - Mock instruction changes
  - Mock delay changes
  - Generate mode changes
  - Request params changes

- When `regenerateOnConfigChange: false`:
  - Only schema structure changes
  - Request params changes

**Use cases:**
- `regenerateOnConfigChange: true` - Recommended for most development scenarios
- `regenerateOnConfigChange: false` - Use when you want stable mock data even when tweaking endpoint config

## Database Schema Sync

**NEW:** Sync your backend database schema to your frontend for type-safe API definitions.

### Overview

The Database Schema Sync feature allows backend teams to upload their database schema to Symulate, which automatically generates TypeScript types. Frontend developers can then reference these types in their endpoint definitions using `m.db()`, ensuring type safety across the entire stack.

### For Backend Developers

1. **Export your database schema:**
```bash
# PostgreSQL
pg_dump --schema-only --no-owner --no-acl mydb > schema.sql
```

2. **Upload to Symulate Dashboard:**
- Navigate to Dashboard ‚Üí Database Schema
- Enter a schema name (e.g., "main", "auth")
- Paste your SQL DDL statements
- Platform automatically detects breaking changes

### For Frontend Developers

1. **Import database types:**
```bash
npx symulate import-schema
```

This creates `./src/types/database.ts` with TypeScript interfaces and a `DatabaseTypes` constant.

2. **Use in endpoint definitions:**
```typescript
import { m, defineEndpoint } from "@symulate/sdk";
import type { User, Post } from "./types/database";

// Reference database columns with m.db()
const getUser = defineEndpoint<User>({
  method: "GET",
  path: "/api/users/:id",
  schema: m.object({
    id: m.db("users.id"),
    name: m.db("users.name", "German names"), // Optional AI instruction
    email: m.db("users.email"),
    created_at: m.db("users.created_at"),
  }),
});

// Fully typed!
const user = await getUser({ id: "123" });
```

### How m.db() Works

The `m.db()` method references database columns while still allowing AI instructions:

```typescript
m.db(tableDotColumn: string, description?: string)
```

**Features:**
- **Type Mapping**: Automatically maps SQL types to TypeScript types
- **AI Compatible**: Optional AI instructions for mock generation
- **Faker Compatible**: Works in CI/CD with deterministic data
- **FK Relationships**: Maintains referential integrity in mock data

**Example:**
```typescript
const schema = m.object({
  // Basic column reference
  id: m.db("users.id"),

  // With AI instruction
  name: m.db("users.name", "Generate realistic German names"),

  // Foreign key - automatically uses valid IDs from referenced table
  author_id: m.db("posts.author_id"), // References users.id
});
```

### Foreign Key Relationships

When using `m.db()` with foreign keys, the system automatically:

1. **Caches generated entities** by table name
2. **Reuses primary key values** from referenced tables
3. **Maintains referential integrity** in mock data

```typescript
// First, generate users
const getUsers = defineEndpoint<User[]>({
  method: "GET",
  path: "/api/users",
  schema: m.array(m.object({
    id: m.db("users.id"),
    name: m.db("users.name"),
  })),
  mock: { count: 5 }
});

// Then, generate posts - author_id will match actual user IDs
const getPosts = defineEndpoint<Post[]>({
  method: "GET",
  path: "/api/posts",
  schema: m.array(m.object({
    id: m.db("posts.id"),
    title: m.db("posts.title"),
    author_id: m.db("posts.author_id"), // Uses real user IDs!
  })),
  mock: { count: 10 }
});
```

### CLI Command Options

```bash
# Import latest schema
npx symulate import-schema

# Import specific schema by name
npx symulate import-schema --schema-name auth

# Update existing types file
npx symulate import-schema --update

# Specify custom output path
npx symulate import-schema --output ./types/db.ts
```

### Breaking Change Detection

The platform automatically detects breaking changes when a new schema version is uploaded:

**Breaking Changes:**
- Table removed
- Column removed
- Column type changed (e.g., `varchar` ‚Üí `int`)
- Nullable ‚Üí NOT NULL conversion

**Non-Breaking Changes:**
- Table added
- Column added (nullable)
- NOT NULL ‚Üí Nullable
- Index changes

When breaking changes are detected:
1. Platform shows warnings in dashboard
2. CLI displays warnings when running `import-schema`
3. TypeScript shows errors where code needs updating

### Benefits

‚úÖ **Single Source of Truth**: Database schema defines TypeScript types
‚úÖ **Type Safety**: Compile-time errors for schema mismatches
‚úÖ **Breaking Change Detection**: Catch issues before deployment
‚úÖ **Team Coordination**: Backend and frontend stay in sync
‚úÖ **Still AI-Powered**: Custom AI instructions work with database types
‚úÖ **Faker Compatible**: Works in CI/CD with deterministic generation

### Example Generated Types

When you run `import-schema`, you get:

```typescript
// Auto-generated ./src/types/database.ts

export const DatabaseTypes = {
  users: {
    id: "uuid", // PK, NOT NULL
    name: "varchar(255)", // NOT NULL
    email: "varchar(255)", // NOT NULL
    created_at: "timestamptz",
    role: "varchar(50)"
  },
  posts: {
    id: "uuid", // PK, NOT NULL
    title: "varchar(500)", // NOT NULL
    content: "text",
    author_id: "uuid", // FK ‚Üí users.id, NOT NULL
    published_at: "timestamptz"
  }
} as const;

export interface User {
  id: string;
  name: string;
  email: string;
  created_at?: string;
  role?: string;
}

export interface Post {
  id: string;
  title: string;
  content?: string | null;
  /** Foreign key to users.id */
  author_id: string;
  published_at?: string | null;
}
```

### Supported SQL Types

The system maps SQL types to TypeScript and generates appropriate mock data:

| SQL Type | TypeScript | Faker Generation |
|----------|-----------|------------------|
| `uuid` | `string` | UUID v4 |
| `varchar`, `text` | `string` | Context-aware (name, email, etc.) |
| `integer`, `int` | `number` | Random integer |
| `decimal`, `numeric` | `number` | Random decimal |
| `boolean` | `boolean` | Random boolean |
| `timestamp`, `timestamptz` | `string` | ISO date string |
| `json`, `jsonb` | `any` | Sample JSON object |

For complete documentation, see [DATABASE_SCHEMA_SYNC.md](../DATABASE_SCHEMA_SYNC.md)

## CLI Commands

### Generate OpenAPI Spec

Generate an OpenAPI 3.0 specification from your defined Symulate endpoints:

```bash
# Basic usage - generates openapi.json
npx Symulate openapi

# Specify output file
npx Symulate openapi -o api-spec.json

# Full customization
npx Symulate openapi \
  -o ./docs/api.json \
  -t "My API" \
  -v "2.0.0" \
  -d "API for My Application" \
  -s https://api.example.com
```

**Options:**
- `-o, --output <path>` - Output file path (default: `./openapi.json`)
- `-t, --title <title>` - API title (default: `Symulate Generated API`)
- `-v, --version <version>` - API version (default: `1.0.0`)
- `-d, --description <description>` - API description
- `-s, --server <url>` - Server URL (e.g., `https://api.example.com`)

The generated spec includes:
- Request/response schemas from your Symulate schemas
- Path parameters (e.g., `:id`)
- Request bodies for POST/PUT/PATCH
- Tags for organization
- Error responses (400, 404, 500)

### Regenerate Mock Data

Clear cached mock data to regenerate fresh data:

```bash
# Clear all cache
npx Symulate regenerate

# Preview what's cached (without clearing)
npx Symulate regenerate --preview

# Clear specific cache entry by hash
npx Symulate regenerate --hash abc123xyz

# Clear entries matching a pattern
npx Symulate regenerate --endpoint users
```

**Options:**
- `--preview, -p` - Show cached endpoints without clearing
- `--hash <hash>, -h` - Clear cache for specific hash
- `--endpoint <pattern>, -e` - Clear cache entries matching pattern

**Example output (preview mode):**
```
üìã Cached Endpoints:

  [1] Hash: abc123xyz
      Cached: 12/21/2025, 3:45 PM
      Preview: {"id":"550e8400-e29b-41d4-a716-446655440000","name":"John Doe","email":"john@example.com"}...

  [2] Hash: def456uvw
      Cached: 12/21/2025, 3:47 PM
      Preview: [{"id":"7c9e6679-7425-40de-944b-e07fc1f90ae7","title":"Product A","price":49.99}...

  Total: 2 cached endpoint(s)

üí° Tip: Run 'npx Symulate regenerate' to clear all cache
        Run 'npx Symulate regenerate --hash <hash>' to clear specific entry
```

### Inspect Cache

Inspect what's currently cached to understand your mock data state:

```bash
# List all cached entries
npx Symulate cache

# Show full data for a specific hash
npx Symulate cache --hash abc123xyz

# Search for entries matching a pattern
npx Symulate cache --search users

# Search with full data output
npx Symulate cache --search products --full
```

**Options:**
- `--list, -l` - List all cached entries (default behavior)
- `--hash <hash>, -h` - Show full details for a specific cache entry
- `--search <pattern>, -s` - Search for entries matching pattern
- `--full, -f` - Show full data instead of preview (use with `--search`)

**Example output (list all):**
```
üìã Cached Endpoints (3 total):

  [1] Hash: abc123xyz
      Cached: 12/21/2025, 3:45 PM
      Preview: {"id":"550e8400-e29b-41d4-a716-446655440000","name":"John Doe","email":"john@example.com"}...

  [2] Hash: def456uvw
      Cached: 12/21/2025, 3:47 PM
      Preview: [{"id":"7c9e6679-7425-40de-944b-e07fc1f90ae7","title":"Product A","price":49.99}...

  [3] Hash: ghi789rst
      Cached: 12/21/2025, 4:12 PM
      Preview: {"userId":"9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d","orderId":"a1b2c3d4","total":199.99}...

üí° Tips:
   - Use 'npx Symulate cache --hash <hash>' to see full data
   - Use 'npx Symulate cache --search <pattern>' to filter entries
   - Use 'npx Symulate regenerate --hash <hash>' to clear specific entry
```

**Example output (specific hash):**
```
üì¶ Cache Entry: abc123xyz
   Cached: 12/21/2025, 3:45 PM
   Schema Hash: abc123xyz

   Data:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-12-20T15:30:00.000Z"
}
```

### Collection Management

Manage stateful collections with CLI commands:

```bash
# List all collections
npx symulate collections list

# List collections for specific branch
npx symulate collections list -b customer-acme

# Delete specific collection
npx symulate collections delete -n products

# Delete collection from specific branch
npx symulate collections delete -n products -b dev

# Delete all collections (requires confirmation)
npx symulate collections delete --all

# Pre-generate all defined collections
npx symulate collections pregenerate

# Pre-generate for specific branch
npx symulate collections pregenerate -b demo
```

**Options:**

**`collections list`**
- `-b, --branch <name>` - Filter by branch name

**`collections delete`**
- `-n, --name <collection>` - Collection name to delete
- `-b, --branch <name>` - Delete only from specific branch
- `--all` - Delete all collections (with confirmation prompt)

**`collections pregenerate`**
- `-b, --branch <name>` - Target branch (default: main)

**Note:** Custom instructions for data generation are only available for tenant demos (created via Platform UI). Development pre-generation uses the `seedInstruction` defined in your collection schemas

**Example output (list):**
```
   Found 2 collection(s):

   ‚Ä¢ products
     ‚îî‚îÄ main (20 items)
     ‚îî‚îÄ customer-acme (15 items)

   ‚Ä¢ users
     ‚îî‚îÄ main (10 items)
```

**Example output (delete --all):**
```
‚ö†Ô∏è  WARNING: You are about to delete ALL collections across ALL branches
   Type "DELETE ALL" to confirm:
```

### Clear Cache

Clear the Symulate cache file (legacy command - use `regenerate` instead):

```bash
npx Symulate clear-cache
```

## Environment Switching

Development (uses mocks):
```bash
NODE_ENV=development npm run dev
```

Production (uses real backend):
```bash
NODE_ENV=production npm run build
```

## Advanced Example

```typescript
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.commerce.productName(),
  price: m.commerce.price(),
  inStock: m.boolean(),
  category: m.object({
    id: m.uuid(),
    name: m.commerce.department(),
  }),
  reviews: m.array(m.object({
    id: m.uuid(),
    rating: m.number(),
    comment: m.lorem.paragraph(),
  })),
});

type Product = Infer<typeof ProductSchema>;

export const getProducts = defineEndpoint<Product[]>({
  path: "/api/products",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 10,
    instruction: "Generate realistic e-commerce products",
  },
});

export const getProduct = defineEndpoint<Product>({
  path: "/api/products/:id",
  method: "GET",
  schema: ProductSchema,
  mock: {},
});

// Usage with dynamic routes
const product = await getProduct({ id: "123" });
```

## Dynamic Parameters & Variable Interpolation

Symulate supports dynamic parameters that can be used in both API calls and AI instructions. This enables context-aware mock data generation based on runtime values.

### Template Syntax

Use `{{variable}}` syntax in your instruction to interpolate parameter values:

```typescript
export const filterOffers = defineEndpoint<Offer[]>({
  method: "GET",
  path: "/api/v1/offers",
  schema: OfferSchema,
  mock: {
    count: 20,
    instruction: "Generate {{filter}} offers for companies in the {{sector}} sector"
  }
});

// Usage - variables are interpolated into the instruction
const offers = await filterOffers({
  filter: "outgoing",
  sector: "construction"
});
// Instruction becomes: "Generate outgoing offers for companies in the construction sector"
```

### Use Cases

**1. Filtering & Search**

```typescript
export const searchProducts = defineEndpoint<Product[]>({
  path: "/api/products/search",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 10,
    instruction: "Generate products matching search query: {{query}}, category: {{category}}"
  }
});

const results = await searchProducts({
  query: "laptop",
  category: "electronics"
});
```

**2. User-Specific Data**

```typescript
export const getUserOrders = defineEndpoint<Order[]>({
  path: "/api/users/:userId/orders",
  method: "GET",
  schema: OrderSchema,
  mock: {
    count: 5,
    instruction: "Generate orders for user with role: {{userRole}}, status: {{status}}"
  }
});

const orders = await getUserOrders({
  userId: "123",
  userRole: "premium",
  status: "completed"
});
```

**3. Date Ranges**

```typescript
export const getAnalytics = defineEndpoint<Analytics>({
  path: "/api/analytics",
  method: "GET",
  schema: AnalyticsSchema,
  mock: {
    instruction: "Generate analytics data for period {{startDate}} to {{endDate}}"
  }
});

const data = await getAnalytics({
  startDate: "2024-01-01",
  endDate: "2024-01-31"
});
```

**4. Localization**

```typescript
export const getContent = defineEndpoint<Content[]>({
  path: "/api/content",
  method: "GET",
  schema: ContentSchema,
  mock: {
    count: 10,
    instruction: "Generate content in {{language}} language for {{region}} region"
  }
});

const content = await getContent({
  language: "German",
  region: "Europe"
});
```

### How It Works

1. **Parameters Passed**: Call endpoint with params object
2. **Variables Interpolated**: `{{variable}}` replaced with actual values
3. **AI Generation**: Interpolated instruction sent to AI
4. **Unique Caching**: Each parameter combination cached separately

```typescript
// First call - generates with "active" status
await getOffers({ filter: "active" });

// Second call - cache miss, different params
// Generates new data with "pending" status
await getOffers({ filter: "pending" });

// Third call - cache hit for "active"
await getOffers({ filter: "active" });
```

### Best Practices

**Clear Variable Names**

```typescript
// Good - descriptive
instruction: "Generate {{userType}} users with {{subscriptionTier}} subscription"

// Avoid - unclear
instruction: "Generate {{type}} users with {{tier}}"
```

**Provide Defaults**

```typescript
// Handling missing variables
const params = {
  filter: filter || "all",
  status: status || "active"
};

await getOrders(params);
```

**Combine with Path Parameters**

```typescript
export const getProjectTasks = defineEndpoint<Task[]>({
  path: "/api/projects/:projectId/tasks",
  method: "GET",
  schema: TaskSchema,
  mock: {
    instruction: "Generate {{status}} tasks for {{projectType}} project"
  }
});

// Both path param and query params
const tasks = await getProjectTasks({
  projectId: "abc-123",      // Path parameter
  status: "in-progress",     // Instruction variable
  projectType: "enterprise"  // Instruction variable
});
```

## Error Handling

You can define custom error responses for your endpoints, which will be included in the OpenAPI specification and can be used for testing error states.

### Basic Error Configuration

```typescript
export const getUser = defineEndpoint({
  path: "/api/users/:id",
  method: "GET",
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  errors: [
    {
      code: 404,
      description: "User not found",
      schema: m.object({
        error: m.object({
          message: m.string(),
          code: m.string(),
          userId: m.uuid(),
        }),
      }),
    },
    {
      code: 403,
      description: "Insufficient permissions",
      schema: m.object({
        error: m.object({
          message: m.string(),
          requiredPermission: m.string(),
        }),
      }),
    },
  ],
});
```

### Testing Error States with `failNow`

Use the `failNow` flag to simulate error responses during development (mock mode only):

```typescript
export const createUser = defineEndpoint({
  path: "/api/users",
  method: "POST",
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  errors: [
    {
      code: 400,
      description: "Invalid user data",
      schema: m.object({
        error: m.object({
          message: m.string(),
          validationErrors: m.array(
            m.object({
              field: m.string(),
              message: m.string(),
            })
          ),
        }),
      }),
      failNow: true, // Request will fail with this error in mock mode
    },
  ],
});

// In development/mock mode, this will throw an error:
try {
  await createUser({ name: "John" });
} catch (error) {
  console.error(error.message); // "[Symulate Mock] HTTP 400: Invalid user data"
  console.log(error.status);    // 400
  console.log(error.data);      // Generated error data matching the schema
}
```

**Note:** The `failNow` flag only affects mock mode (development). In production mode, requests will be sent to your real backend regardless of this flag.

### Default Error Responses

If no `errors` are specified, the OpenAPI spec will include default error responses (400, 404, 500) with a standard error schema.

## Type Validation

Symulate automatically validates backend responses in production mode:

```typescript
import { TypeValidationError } from "@symulate/sdk";

try {
  const users = await getUsers();
} catch (error) {
  if (error instanceof TypeValidationError) {
    console.error("Validation failed at:", error.path);
    console.error("Expected:", error.expected);
    console.error("Received:", error.received);
  }
}
```

## Local Development

Developing or testing the SDK with local/test Supabase instances? See **[DEVELOPMENT.md](DEVELOPMENT.md)** for instructions on using environment variables to override production URLs.

**Quick start:**
```bash
cp .env.example .env.local
# Edit .env.local with your test credentials
npm run build
```

## Documentation

For full documentation, visit the [main repository](https://github.com/yourusername/Symulate).

## License

MIT
