# Symulate SDK

AI-powered frontend-first development toolkit. Build your frontend without waiting for a backend.

## Features

- **Zero Backend Dependency**: Develop frontend-first with automatic mock data generation
- **AI-Powered Mocks**: Realistic data generated by OpenAI with intelligent caching
- **Database Schema Sync**: Reference backend database types directly with `m.db()`
- **Faker.js Mode**: Offline mode for CI/CD pipelines - no AI dependency required
- **Schema-Based Type System**: Zod-like schema builder for single source of truth
- **Type-Safe**: Full TypeScript support with automatic type inference
- **Seamless Production Switch**: One config change to switch from mocks to real backend
- **Smart Caching**: In-memory, localStorage, or file-based caching strategies
- **Performance Optimized**: <10ms mock generation after first AI cache
- **OpenAPI Generation**: Auto-generate API specs for backend developers
- **CI/CD Ready**: Deterministic Faker.js mode with seed support for testing
- **Breaking Change Detection**: Automatic detection of schema changes that break frontend code

## Installation

```bash
npm install @symulate/sdk
```

## Quick Start

```typescript
import { defineEndpoint, configureSymulate, m, type Infer } from "@symulate/sdk";

// Configure Symulate
// Get your free API key and project ID at https://platform.symulate.dev
configureSymulate({
  symulateApiKey: process.env.SYMULATE_API_KEY,
  projectId: process.env.SYMULATE_PROJECT_ID, // Required for API requests
  backendBaseUrl: "https://api.myapp.com", // For production
  environment: process.env.NODE_ENV === "production" ? "production" : "development",
  cacheEnabled: true,
  persistentCache: true, // Enable localStorage persistence in browser
});

// Define schema
const UserSchema = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  email: m.email(),
});

// Infer TypeScript type
type User = Infer<typeof UserSchema>;

// Define endpoint
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET",
  schema: UserSchema,
  mock: {
    count: 5,
  },
});

// Use it
const users = await getUsers();
console.log(users); // Fully typed as User[]
```

## Configuration

Get your free API key and project ID at [https://platform.symulate.dev](https://platform.symulate.dev)

```typescript
configureSymulate({
  symulateApiKey: string,         // Symulate Platform API key (sym_live_xxx) - required for AI generation
  projectId: string,             // Project ID for multi-project isolation - required
  backendBaseUrl: string,        // Real backend URL for production
  environment: "development" | "production",
  cacheEnabled: boolean,         // Enable/disable caching (default: true)
  persistentCache: boolean,      // Enable localStorage persistence in browser (default: false)
  generateMode: "ai" | "faker" | "auto",  // Generation mode (default: "auto")
  fakerSeed: number,             // Seed for deterministic Faker.js generation (optional)
  regenerateOnConfigChange: boolean,  // Regenerate when endpoint config changes (default: true)
});
```

## Generation Modes

Symulate supports three generation modes to fit different development scenarios:

### AI Mode (Realistic Data)
Best for development and prototyping with realistic, contextual data.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx",
  generateMode: "ai", // Always use AI - requires API key
});
```

**Use cases:**
- Frontend development with realistic data
- UI/UX prototyping
- Demos and presentations

### Faker Mode (CI/CD & Offline)
Pure Faker.js generation without network dependency. Perfect for CI/CD pipelines.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx", // Required (free tier = unlimited Faker)
  generateMode: "faker",
  fakerSeed: 12345,             // Optional: deterministic data for tests
});
```

**Use cases:**
- CI/CD pipelines (Jenkins, GitHub Actions)
- Integration tests
- Offline development (after initial API key setup)
- Air-gapped environments

**Benefits:**
- ‚úÖ No network calls during generation
- ‚úÖ **Unlimited on free tier**
- ‚úÖ Fast generation (<1ms)
- ‚úÖ Deterministic with seed (reproducible tests)

**Note:** API key required for all modes (including Faker) for user tracking and quota management. Free tier includes unlimited Faker.js mode.

### Auto Mode (Default - Best of Both)
Tries AI first, falls back to Faker.js if API key is missing or network fails.

```typescript
configureSymulate({
  symulateApiKey: "sym_live_xxx", // Optional
  generateMode: "auto", // Default mode
});
```

**Use cases:**
- Teams with mixed workflows
- Gradual adoption
- Offline-first development

## CI/CD Example

Use Faker mode in your test pipeline for fast, deterministic mocks:

```typescript
// jest.setup.ts or vitest.config.ts
import { configureSymulate } from "@symulate/sdk";

configureSymulate({
  symulateApiKey: process.env.Symulate_API_KEY, // Required (use free tier)
  generateMode: "faker",                       // No network calls
  fakerSeed: 12345,                            // Same data every test run
  environment: "development",
  cacheEnabled: true,
});
```

```yaml
# .github/workflows/test.yml
- name: Run tests
  run: npm test
  env:
    NODE_ENV: development
    Symulate_API_KEY: ${{ secrets.Symulate_API_KEY }} # Free tier = unlimited Faker
```

**Why API key is required:**
- ‚úÖ User tracking (helps us improve the product)
- ‚úÖ Quota management (prevents abuse)
- ‚úÖ **Free tier includes unlimited Faker.js mode** - perfect for CI/CD
- ‚úÖ No network calls are made in Faker mode (offline-safe)

### Getting Started

1. Sign up for a free account at [https://platform.symulate.dev](https://platform.symulate.dev)
2. Create an API key from your dashboard
3. Add the API key to your environment variables:
   ```bash
   Symulate_API_KEY=sym_live_your_api_key_here
   ```
4. Configure Symulate in your app (see Quick Start above)

## Schema Builder (`m`)

### Basic Types

```typescript
const schema = m.object({
  id: m.uuid(),
  text: m.string(),
  count: m.number(),
  active: m.boolean(),
  createdAt: m.date(),
  email: m.email(),
  website: m.url(),
  phone: m.phoneNumber(),
});
```

### Person Fields

```typescript
const person = m.object({
  fullName: m.person.fullName(),
  firstName: m.person.firstName(),
  lastName: m.person.lastName(),
  jobTitle: m.person.jobTitle(),
});
```

### Internet Fields

```typescript
const profile = m.object({
  userName: m.internet.userName(),
  avatar: m.internet.avatar(),
});
```

### Location Fields

```typescript
const address = m.object({
  street: m.location.street(),
  city: m.location.city(),
  state: m.location.state(),
  zipCode: m.location.zipCode(),
  country: m.location.country(),
  latitude: m.location.latitude(),
  longitude: m.location.longitude(),
});
```

### Commerce Fields

```typescript
const product = m.object({
  name: m.commerce.productName(),
  department: m.commerce.department(),
  price: m.commerce.price(),
});
```

### Lorem Fields

```typescript
const content = m.object({
  word: m.lorem.word(),
  sentence: m.lorem.sentence(),
  paragraph: m.lorem.paragraph(),
});
```

### Nested Objects

```typescript
const user = m.object({
  id: m.uuid(),
  name: m.person.fullName(),
  address: m.object({
    street: m.location.street(),
    city: m.location.city(),
  }),
});
```

### Arrays

```typescript
const article = m.object({
  id: m.uuid(),
  title: m.lorem.sentence(),
  tags: m.array(m.lorem.word()),
});
```

## Type Inference

Use `Infer<>` to extract TypeScript types from schemas:

```typescript
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.commerce.productName(),
  price: m.commerce.price(),
});

type Product = Infer<typeof ProductSchema>;
// { id: string; name: string; price: number }
```

## Mock Configuration

```typescript
mock: {
  count: 10, // Generate array of 10 items
  instruction: "Generate premium users with verified accounts", // Optional AI instruction
  delay: 500, // Simulate loading delay in milliseconds (only for cached data)
}
```

### Simulating Network Latency

The `delay` option allows you to simulate realistic network latency for cached mock data. This is useful for:
- Testing loading states and spinners
- Simulating slow network conditions
- Demonstrating progressive loading UIs
- E2E tests that expect async behavior

```typescript
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET",
  schema: UserSchema,
  mock: {
    count: 5,
    delay: 800, // Simulate 800ms network latency
  },
});

// Usage - will wait 800ms before returning cached data
const users = await getUsers(); // Takes ~800ms when cache hit
```

**Important Notes:**
- Delay only applies to **cached data** (cache hits)
- First request (cache miss) uses actual AI/Faker generation time
- Set `delay: 0` or omit it for instant responses
- Useful for testing loading states without slowing down development

### Contextual Metadata

The `metadata` option allows you to pass additional contextual information to the AI for more accurate mock data generation. Unlike `instruction` which provides natural language guidance, `metadata` provides structured data that the AI can use to generate more realistic, context-aware values.

```typescript
mock: {
  count: 10,
  instruction: "Generate employees from a tech company",
  metadata: {
    industry: "Technology",
    companySize: "500-1000",
    region: "North America",
    averageSalary: "$120,000",
    techStack: ["React", "Node.js", "PostgreSQL"]
  }
}
```

**Use Cases:**

**1. Domain-Specific Context**

```typescript
export const getProducts = defineEndpoint<Product[]>({
  path: "/api/products",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 20,
    instruction: "Generate e-commerce products",
    metadata: {
      productCategory: "Electronics",
      priceRange: { min: 50, max: 2000 },
      targetMarket: "Premium consumers",
      brand: "TechPro"
    }
  }
});
// AI will generate electronics products within the price range for the target market
```

**2. User Demographics**

```typescript
export const getCustomers = defineEndpoint<Customer[]>({
  path: "/api/customers",
  method: "GET",
  schema: CustomerSchema,
  mock: {
    count: 50,
    metadata: {
      ageRange: "25-45",
      location: "Urban areas in Germany",
      income: "Above average",
      interests: ["Technology", "Travel", "Sustainability"]
    }
  }
});
// Generates customers matching the demographic profile
```

**3. Business Context**

```typescript
export const getOrders = defineEndpoint<Order[]>({
  path: "/api/orders",
  method: "GET",
  schema: OrderSchema,
  mock: {
    count: 100,
    instruction: "Generate recent orders",
    metadata: {
      businessHours: "9am-5pm EST",
      peakSeason: "Q4",
      averageOrderValue: "$150",
      customerType: "B2B",
      paymentMethods: ["Invoice", "Corporate Credit Card"]
    }
  }
});
// Orders will reflect B2B patterns and payment methods
```

**4. Regional/Cultural Context**

```typescript
export const getRestaurants = defineEndpoint<Restaurant[]>({
  path: "/api/restaurants",
  method: "GET",
  schema: RestaurantSchema,
  mock: {
    count: 15,
    instruction: "Generate restaurant listings",
    metadata: {
      cuisine: "Japanese",
      priceLevel: "$$-$$$",
      city: "Berlin",
      culturalPreferences: "Authentic ingredients, Modern presentation"
    }
  }
});
// AI generates realistic Japanese restaurants appropriate for Berlin
```

**How It Works:**

1. **Structured Data**: Metadata is passed as a JSON object, allowing complex nested data
2. **AI Integration**: The AI uses metadata to inform every generated field, not just specific ones
3. **Cache Invalidation**: Different metadata values generate different cache keys
4. **Type Safety**: Use TypeScript to define metadata shapes for consistency

**Best Practices:**

```typescript
// Good - Specific, structured context
metadata: {
  industry: "Healthcare",
  complianceStandards: ["HIPAA", "GDPR"],
  dataClassification: "PHI",
  userRoles: ["Doctor", "Nurse", "Admin"]
}

// Avoid - Too vague or redundant with instruction
metadata: {
  type: "users",
  makeItRealistic: true
}
```

**Metadata vs Instruction:**
- **Instruction**: Natural language guidance on *what* to generate ("Generate premium users")
- **Metadata**: Structured context about *how* to generate it (industry, region, demographics)
- **Use both**: Combine for best results

```typescript
mock: {
  count: 100,
  instruction: "Generate active enterprise customers with recent purchases",
  metadata: {
    industry: "Manufacturing",
    companySize: "1000+",
    contractValue: "$50k-$500k/year",
    region: "EMEA",
    productCategories: ["Industrial Equipment", "Maintenance Supplies"]
  }
}
// Instruction guides overall theme, metadata provides specific constraints
```

### Runtime Metadata

You can pass metadata dynamically at runtime when calling an endpoint, allowing context-specific data generation based on user input, component state, or application context.

**Basic Usage:**

```typescript
export const getEmployees = defineEndpoint<Employee[]>({
  path: '/api/employees',
  method: 'GET',
  schema: EmployeeSchema,
  mock: {
    count: 50,
    instruction: "Generate employees from a tech company"
  }
});

// Pass metadata at call time
const employees = await getEmployees({
  metadata: {
    industry: "Healthcare",
    companySize: "100-500",
    region: "APAC"
  }
});
```

**Merging Behavior:**

Runtime metadata is merged with configured metadata, with runtime values taking precedence:

```typescript
export const getProducts = defineEndpoint<Product[]>({
  path: '/api/products',
  method: 'GET',
  schema: ProductSchema,
  mock: {
    count: 20,
    metadata: {
      category: "Electronics",
      brand: "TechPro",
      priceRange: { min: 50, max: 500 }
    }
  }
});

// Override brand, keep category and priceRange, add new field
const products = await getProducts({
  metadata: {
    brand: "SuperTech",  // Overrides configured brand
    targetMarket: "Budget consumers"  // Adds new context
  }
});
// Merged metadata:
// {
//   category: "Electronics",      ‚Üê From config
//   brand: "SuperTech",           ‚Üê Overridden at runtime
//   priceRange: { min: 50, ... }, ‚Üê From config
//   targetMarket: "Budget..."     ‚Üê Added at runtime
// }
```

**Use Cases:**

1. **User-Driven Context**
```typescript
const getRecommendations = defineEndpoint<Product[]>({
  path: '/api/recommendations',
  method: 'GET',
  schema: ProductSchema,
  mock: { count: 10 }
});

// Adapt to user preferences
const recommendations = await getRecommendations({
  metadata: {
    userAge: user.age,
    userInterests: user.interests,
    pricePreference: user.budget,
    location: user.location
  }
});
```

2. **Dynamic Filters**
```typescript
const searchResults = await searchProducts({
  query: searchQuery,
  metadata: {
    category: selectedCategory,
    priceRange: priceFilter,
    inStock: showInStockOnly,
    sortBy: sortOption
  }
});
```

3. **A/B Testing**
```typescript
const users = await getUsers({
  metadata: {
    experiment: "variant_b",
    cohort: "premium_users",
    featureFlags: ["new_ui", "advanced_search"]
  }
});
```

4. **Localization**
```typescript
const content = await getContent({
  metadata: {
    language: currentLocale,
    region: userRegion,
    currency: preferredCurrency,
    dateFormat: localeDateFormat
  }
});
```

**Important Notes:**

- Metadata is NOT sent to your backend in production mode - it's only used for mock data generation
- Runtime metadata does not require parameter definitions - it's automatically excluded from validation
- Empty metadata objects (`metadata: {}`) are handled gracefully
- Nested objects and arrays are fully supported in runtime metadata

## Parameters

Define typed parameters for your endpoints with automatic validation and proper routing in both mock and production modes.

### Basic Usage

```typescript
const getUserById = defineEndpoint({
  path: "/api/users/:id",
  method: "GET",
  params: [
    {
      name: "id",
      location: "path",
      required: true,
      schema: m.uuid(),
      description: "The unique identifier of the user",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
});

// Usage - parameters are validated
const user = await getUserById({ id: "123e4567-e89b-12d3-a456-426614174000" });
```

### Parameter Locations

Parameters can be defined in four locations:

| Location | Description | Example |
|----------|-------------|---------|
| `path` | URL path segments | `/users/:id` |
| `query` | Query string parameters | `?page=1&limit=10` |
| `header` | HTTP headers | `Authorization: Bearer token` |
| `body` | Request body (POST/PUT/PATCH) | `{ name: "John" }` |

### Query Parameters

```typescript
const listUsers = defineEndpoint({
  path: "/api/users",
  method: "GET",
  params: [
    {
      name: "page",
      location: "query",
      required: false,
      schema: m.number(),
      description: "Page number for pagination",
      example: 1,
    },
    {
      name: "limit",
      location: "query",
      required: false,
      schema: m.number(),
      description: "Number of items per page",
      example: 10,
    },
    {
      name: "search",
      location: "query",
      required: false,
      schema: m.string(),
      description: "Search term to filter users",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  mock: { count: 10 },
});

// Usage
const users = await listUsers({ page: 1, limit: 20, search: "john" });
```

### Header Parameters

```typescript
const getProtectedData = defineEndpoint({
  path: "/api/protected/data",
  method: "GET",
  params: [
    {
      name: "Authorization",
      location: "header",
      required: true,
      schema: m.string(),
      description: "Bearer token for authentication",
    },
    {
      name: "X-API-Key",
      location: "header",
      required: false,
      schema: m.string(),
      description: "Optional API key",
    },
  ],
  schema: m.object({
    data: m.string(),
  }),
});

// Usage
const data = await getProtectedData({
  Authorization: "Bearer your-token",
  "X-API-Key": "optional-key",
});
```

### Mixed Parameters

Combine different parameter types:

```typescript
const createOffer = defineEndpoint({
  path: "/api/organizations/:orgId/offers",
  method: "POST",
  params: [
    // Path parameter
    {
      name: "orgId",
      location: "path",
      required: true,
      schema: m.uuid(),
      description: "Organization ID",
    },
    // Query parameters
    {
      name: "notify",
      location: "query",
      required: false,
      schema: m.boolean(),
      description: "Send notification email",
      example: true,
    },
    // Header parameter
    {
      name: "Authorization",
      location: "header",
      required: true,
      schema: m.string(),
      description: "Authentication token",
    },
    // Body parameters
    {
      name: "customer_name",
      location: "body",
      required: true,
      schema: m.string(),
      description: "Customer name",
    },
    {
      name: "amount",
      location: "body",
      required: true,
      schema: m.number(),
      description: "Offer amount",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    customer_name: m.string(),
    amount: m.number(),
    status: m.string(),
  }),
});

// Usage
const offer = await createOffer({
  orgId: "org-123",
  notify: true,
  Authorization: "Bearer token",
  customer_name: "Acme Corp",
  amount: 5000,
});

// In production mode, this produces:
// POST /api/organizations/org-123/offers?notify=true
// Headers:
//   Authorization: Bearer token
// Body:
//   { "customer_name": "Acme Corp", "amount": 5000 }
```

### Parameter Validation

Required parameters are validated at runtime:

```typescript
const searchProducts = defineEndpoint({
  path: "/api/products/search",
  method: "GET",
  params: [
    {
      name: "q",
      location: "query",
      required: true, // Required!
      schema: m.string(),
      description: "Search query",
    },
  ],
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
  }),
});

// This works
await searchProducts({ q: "laptop" });

// This throws an error
await searchProducts({ category: "electronics" });
// Error: [Symulate] Missing required parameters for GET /api/products/search: q (query)
```

### Production Mode Behavior

In production mode, parameters are routed correctly:

- **Path parameters** ‚Üí URL path replacement
- **Query parameters** ‚Üí Query string (`?key=value`)
- **Header parameters** ‚Üí HTTP headers
- **Body parameters** ‚Üí JSON request body

This ensures your endpoints work identically in both mock and production modes.

### Per-Endpoint Mode Override

You can override the global environment setting for specific endpoints using the `mode` parameter. This is useful when you want to test specific mock endpoints in a production application, or use real backend data for certain endpoints during development.

```typescript
// Global config set to production
configureSymulate({
  environment: "production",
  backendBaseUrl: "https://api.myapp.com",
});

// This endpoint uses mock data even though global env is production
export const getNewFeature = defineEndpoint({
  path: "/api/new-feature",
  method: "GET",
  mode: "mock", // Force mock mode for this endpoint
  schema: m.object({
    featureName: m.string(),
    enabled: m.boolean(),
  }),
});

// This endpoint uses production backend (respects global config)
export const getExistingData = defineEndpoint({
  path: "/api/existing-data",
  method: "GET",
  // No mode specified - uses global environment setting
  schema: m.object({
    data: m.string(),
  }),
});

// This endpoint forces production backend even in development
export const getCriticalData = defineEndpoint({
  path: "/api/critical-data",
  method: "GET",
  mode: "production", // Force production mode
  schema: m.object({
    balance: m.number(),
  }),
});
```

**Use cases:**
- **Testing new features in production apps**: Set global env to `production`, but use `mode: "mock"` for new feature endpoints you're still developing
- **Mix real and mock data**: Use real backend for stable features, mock data for features under development
- **Critical data in development**: Force certain endpoints to always use production backend (e.g., payment data, user balances)
- **Integration testing**: Test how your app behaves with a mix of real and mock APIs

**Mode options:**
- `mode: "mock"` - Always generate mock data (AI or Faker based on `generateMode`)
- `mode: "production"` - Always call the real backend API
- No mode specified - Falls back to global `environment` setting

## Caching Strategies

### Browser (default)
In-memory cache (clears on page reload):
```typescript
configureSymulate({ cacheEnabled: true });
```

### Browser (persistent)
localStorage cache (persists across reloads):
```typescript
configureSymulate({
  cacheEnabled: true,
  persistentCache: true,
});
```

### Node.js
File-based cache (`.Symulate-cache.json`) - automatic

### Cache Invalidation on Config Changes

By default, Symulate regenerates mock data when your endpoint configuration changes (e.g., changing the HTTP method, mock count, or mock instruction). This ensures your mocked data always matches your current configuration.

```typescript
// Default behavior - cache invalidates when config changes
configureSymulate({
  regenerateOnConfigChange: true, // default
});

// Example: Changing the endpoint config will trigger regeneration
export const getUsers = defineEndpoint<User[]>({
  path: "/api/users",
  method: "GET", // If you change this to "POST", cache invalidates
  schema: UserSchema,
  mock: {
    count: 5, // If you change this to 10, cache invalidates
    instruction: "Generate users from tech companies", // Changing this invalidates cache
  },
});
```

**Disable config-based invalidation:**
```typescript
// Cache only invalidates on schema changes, not config changes
configureSymulate({
  regenerateOnConfigChange: false,
});
```

**What triggers cache invalidation:**
- When `regenerateOnConfigChange: true` (default):
  - Schema structure changes
  - HTTP method changes
  - Mock count changes
  - Mock instruction changes
  - Mock delay changes
  - Generate mode changes
  - Request params changes

- When `regenerateOnConfigChange: false`:
  - Only schema structure changes
  - Request params changes

**Use cases:**
- `regenerateOnConfigChange: true` - Recommended for most development scenarios
- `regenerateOnConfigChange: false` - Use when you want stable mock data even when tweaking endpoint config

## Database Schema Sync

**NEW:** Sync your backend database schema to your frontend for type-safe API definitions.

### Overview

The Database Schema Sync feature allows backend teams to upload their database schema to Symulate, which automatically generates TypeScript types. Frontend developers can then reference these types in their endpoint definitions using `m.db()`, ensuring type safety across the entire stack.

### For Backend Developers

1. **Export your database schema:**
```bash
# PostgreSQL
pg_dump --schema-only --no-owner --no-acl mydb > schema.sql
```

2. **Upload to Symulate Dashboard:**
- Navigate to Dashboard ‚Üí Database Schema
- Enter a schema name (e.g., "main", "auth")
- Paste your SQL DDL statements
- Platform automatically detects breaking changes

### For Frontend Developers

1. **Import database types:**
```bash
npx symulate import-schema
```

This creates `./src/types/database.ts` with TypeScript interfaces and a `DatabaseTypes` constant.

2. **Use in endpoint definitions:**
```typescript
import { m, defineEndpoint } from "@symulate/sdk";
import type { User, Post } from "./types/database";

// Reference database columns with m.db()
const getUser = defineEndpoint<User>({
  method: "GET",
  path: "/api/users/:id",
  schema: m.object({
    id: m.db("users.id"),
    name: m.db("users.name", "German names"), // Optional AI instruction
    email: m.db("users.email"),
    created_at: m.db("users.created_at"),
  }),
});

// Fully typed!
const user = await getUser({ id: "123" });
```

### How m.db() Works

The `m.db()` method references database columns while still allowing AI instructions:

```typescript
m.db(tableDotColumn: string, description?: string)
```

**Features:**
- **Type Mapping**: Automatically maps SQL types to TypeScript types
- **AI Compatible**: Optional AI instructions for mock generation
- **Faker Compatible**: Works in CI/CD with deterministic data
- **FK Relationships**: Maintains referential integrity in mock data

**Example:**
```typescript
const schema = m.object({
  // Basic column reference
  id: m.db("users.id"),

  // With AI instruction
  name: m.db("users.name", "Generate realistic German names"),

  // Foreign key - automatically uses valid IDs from referenced table
  author_id: m.db("posts.author_id"), // References users.id
});
```

### Foreign Key Relationships

When using `m.db()` with foreign keys, the system automatically:

1. **Caches generated entities** by table name
2. **Reuses primary key values** from referenced tables
3. **Maintains referential integrity** in mock data

```typescript
// First, generate users
const getUsers = defineEndpoint<User[]>({
  method: "GET",
  path: "/api/users",
  schema: m.array(m.object({
    id: m.db("users.id"),
    name: m.db("users.name"),
  })),
  mock: { count: 5 }
});

// Then, generate posts - author_id will match actual user IDs
const getPosts = defineEndpoint<Post[]>({
  method: "GET",
  path: "/api/posts",
  schema: m.array(m.object({
    id: m.db("posts.id"),
    title: m.db("posts.title"),
    author_id: m.db("posts.author_id"), // Uses real user IDs!
  })),
  mock: { count: 10 }
});
```

### CLI Command Options

```bash
# Import latest schema
npx symulate import-schema

# Import specific schema by name
npx symulate import-schema --schema-name auth

# Update existing types file
npx symulate import-schema --update

# Specify custom output path
npx symulate import-schema --output ./types/db.ts
```

### Breaking Change Detection

The platform automatically detects breaking changes when a new schema version is uploaded:

**Breaking Changes:**
- Table removed
- Column removed
- Column type changed (e.g., `varchar` ‚Üí `int`)
- Nullable ‚Üí NOT NULL conversion

**Non-Breaking Changes:**
- Table added
- Column added (nullable)
- NOT NULL ‚Üí Nullable
- Index changes

When breaking changes are detected:
1. Platform shows warnings in dashboard
2. CLI displays warnings when running `import-schema`
3. TypeScript shows errors where code needs updating

### Benefits

‚úÖ **Single Source of Truth**: Database schema defines TypeScript types
‚úÖ **Type Safety**: Compile-time errors for schema mismatches
‚úÖ **Breaking Change Detection**: Catch issues before deployment
‚úÖ **Team Coordination**: Backend and frontend stay in sync
‚úÖ **Still AI-Powered**: Custom AI instructions work with database types
‚úÖ **Faker Compatible**: Works in CI/CD with deterministic generation

### Example Generated Types

When you run `import-schema`, you get:

```typescript
// Auto-generated ./src/types/database.ts

export const DatabaseTypes = {
  users: {
    id: "uuid", // PK, NOT NULL
    name: "varchar(255)", // NOT NULL
    email: "varchar(255)", // NOT NULL
    created_at: "timestamptz",
    role: "varchar(50)"
  },
  posts: {
    id: "uuid", // PK, NOT NULL
    title: "varchar(500)", // NOT NULL
    content: "text",
    author_id: "uuid", // FK ‚Üí users.id, NOT NULL
    published_at: "timestamptz"
  }
} as const;

export interface User {
  id: string;
  name: string;
  email: string;
  created_at?: string;
  role?: string;
}

export interface Post {
  id: string;
  title: string;
  content?: string | null;
  /** Foreign key to users.id */
  author_id: string;
  published_at?: string | null;
}
```

### Supported SQL Types

The system maps SQL types to TypeScript and generates appropriate mock data:

| SQL Type | TypeScript | Faker Generation |
|----------|-----------|------------------|
| `uuid` | `string` | UUID v4 |
| `varchar`, `text` | `string` | Context-aware (name, email, etc.) |
| `integer`, `int` | `number` | Random integer |
| `decimal`, `numeric` | `number` | Random decimal |
| `boolean` | `boolean` | Random boolean |
| `timestamp`, `timestamptz` | `string` | ISO date string |
| `json`, `jsonb` | `any` | Sample JSON object |

For complete documentation, see [DATABASE_SCHEMA_SYNC.md](../DATABASE_SCHEMA_SYNC.md)

## CLI Commands

### Generate OpenAPI Spec

Generate an OpenAPI 3.0 specification from your defined Symulate endpoints:

```bash
# Basic usage - generates openapi.json
npx Symulate openapi

# Specify output file
npx Symulate openapi -o api-spec.json

# Full customization
npx Symulate openapi \
  -o ./docs/api.json \
  -t "My API" \
  -v "2.0.0" \
  -d "API for My Application" \
  -s https://api.example.com
```

**Options:**
- `-o, --output <path>` - Output file path (default: `./openapi.json`)
- `-t, --title <title>` - API title (default: `Symulate Generated API`)
- `-v, --version <version>` - API version (default: `1.0.0`)
- `-d, --description <description>` - API description
- `-s, --server <url>` - Server URL (e.g., `https://api.example.com`)

The generated spec includes:
- Request/response schemas from your Symulate schemas
- Path parameters (e.g., `:id`)
- Request bodies for POST/PUT/PATCH
- Tags for organization
- Error responses (400, 404, 500)

### Regenerate Mock Data

Clear cached mock data to regenerate fresh data:

```bash
# Clear all cache
npx Symulate regenerate

# Preview what's cached (without clearing)
npx Symulate regenerate --preview

# Clear specific cache entry by hash
npx Symulate regenerate --hash abc123xyz

# Clear entries matching a pattern
npx Symulate regenerate --endpoint users
```

**Options:**
- `--preview, -p` - Show cached endpoints without clearing
- `--hash <hash>, -h` - Clear cache for specific hash
- `--endpoint <pattern>, -e` - Clear cache entries matching pattern

**Example output (preview mode):**
```
üìã Cached Endpoints:

  [1] Hash: abc123xyz
      Cached: 12/21/2025, 3:45 PM
      Preview: {"id":"550e8400-e29b-41d4-a716-446655440000","name":"John Doe","email":"john@example.com"}...

  [2] Hash: def456uvw
      Cached: 12/21/2025, 3:47 PM
      Preview: [{"id":"7c9e6679-7425-40de-944b-e07fc1f90ae7","title":"Product A","price":49.99}...

  Total: 2 cached endpoint(s)

üí° Tip: Run 'npx Symulate regenerate' to clear all cache
        Run 'npx Symulate regenerate --hash <hash>' to clear specific entry
```

### Inspect Cache

Inspect what's currently cached to understand your mock data state:

```bash
# List all cached entries
npx Symulate cache

# Show full data for a specific hash
npx Symulate cache --hash abc123xyz

# Search for entries matching a pattern
npx Symulate cache --search users

# Search with full data output
npx Symulate cache --search products --full
```

**Options:**
- `--list, -l` - List all cached entries (default behavior)
- `--hash <hash>, -h` - Show full details for a specific cache entry
- `--search <pattern>, -s` - Search for entries matching pattern
- `--full, -f` - Show full data instead of preview (use with `--search`)

**Example output (list all):**
```
üìã Cached Endpoints (3 total):

  [1] Hash: abc123xyz
      Cached: 12/21/2025, 3:45 PM
      Preview: {"id":"550e8400-e29b-41d4-a716-446655440000","name":"John Doe","email":"john@example.com"}...

  [2] Hash: def456uvw
      Cached: 12/21/2025, 3:47 PM
      Preview: [{"id":"7c9e6679-7425-40de-944b-e07fc1f90ae7","title":"Product A","price":49.99}...

  [3] Hash: ghi789rst
      Cached: 12/21/2025, 4:12 PM
      Preview: {"userId":"9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d","orderId":"a1b2c3d4","total":199.99}...

üí° Tips:
   - Use 'npx Symulate cache --hash <hash>' to see full data
   - Use 'npx Symulate cache --search <pattern>' to filter entries
   - Use 'npx Symulate regenerate --hash <hash>' to clear specific entry
```

**Example output (specific hash):**
```
üì¶ Cache Entry: abc123xyz
   Cached: 12/21/2025, 3:45 PM
   Schema Hash: abc123xyz

   Data:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2025-12-20T15:30:00.000Z"
}
```

### Clear Cache

Clear the Symulate cache file (legacy command - use `regenerate` instead):

```bash
npx Symulate clear-cache
```

## Environment Switching

Development (uses mocks):
```bash
NODE_ENV=development npm run dev
```

Production (uses real backend):
```bash
NODE_ENV=production npm run build
```

## Advanced Example

```typescript
const ProductSchema = m.object({
  id: m.uuid(),
  name: m.commerce.productName(),
  price: m.commerce.price(),
  inStock: m.boolean(),
  category: m.object({
    id: m.uuid(),
    name: m.commerce.department(),
  }),
  reviews: m.array(m.object({
    id: m.uuid(),
    rating: m.number(),
    comment: m.lorem.paragraph(),
  })),
});

type Product = Infer<typeof ProductSchema>;

export const getProducts = defineEndpoint<Product[]>({
  path: "/api/products",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 10,
    instruction: "Generate realistic e-commerce products",
  },
});

export const getProduct = defineEndpoint<Product>({
  path: "/api/products/:id",
  method: "GET",
  schema: ProductSchema,
  mock: {},
});

// Usage with dynamic routes
const product = await getProduct({ id: "123" });
```

## Dynamic Parameters & Variable Interpolation

Symulate supports dynamic parameters that can be used in both API calls and AI instructions. This enables context-aware mock data generation based on runtime values.

### Template Syntax

Use `{{variable}}` syntax in your instruction to interpolate parameter values:

```typescript
export const filterOffers = defineEndpoint<Offer[]>({
  method: "GET",
  path: "/api/v1/offers",
  schema: OfferSchema,
  mock: {
    count: 20,
    instruction: "Generate {{filter}} offers for companies in the {{sector}} sector"
  }
});

// Usage - variables are interpolated into the instruction
const offers = await filterOffers({
  filter: "outgoing",
  sector: "construction"
});
// Instruction becomes: "Generate outgoing offers for companies in the construction sector"
```

### Use Cases

**1. Filtering & Search**

```typescript
export const searchProducts = defineEndpoint<Product[]>({
  path: "/api/products/search",
  method: "GET",
  schema: ProductSchema,
  mock: {
    count: 10,
    instruction: "Generate products matching search query: {{query}}, category: {{category}}"
  }
});

const results = await searchProducts({
  query: "laptop",
  category: "electronics"
});
```

**2. User-Specific Data**

```typescript
export const getUserOrders = defineEndpoint<Order[]>({
  path: "/api/users/:userId/orders",
  method: "GET",
  schema: OrderSchema,
  mock: {
    count: 5,
    instruction: "Generate orders for user with role: {{userRole}}, status: {{status}}"
  }
});

const orders = await getUserOrders({
  userId: "123",
  userRole: "premium",
  status: "completed"
});
```

**3. Date Ranges**

```typescript
export const getAnalytics = defineEndpoint<Analytics>({
  path: "/api/analytics",
  method: "GET",
  schema: AnalyticsSchema,
  mock: {
    instruction: "Generate analytics data for period {{startDate}} to {{endDate}}"
  }
});

const data = await getAnalytics({
  startDate: "2024-01-01",
  endDate: "2024-01-31"
});
```

**4. Localization**

```typescript
export const getContent = defineEndpoint<Content[]>({
  path: "/api/content",
  method: "GET",
  schema: ContentSchema,
  mock: {
    count: 10,
    instruction: "Generate content in {{language}} language for {{region}} region"
  }
});

const content = await getContent({
  language: "German",
  region: "Europe"
});
```

### How It Works

1. **Parameters Passed**: Call endpoint with params object
2. **Variables Interpolated**: `{{variable}}` replaced with actual values
3. **AI Generation**: Interpolated instruction sent to AI
4. **Unique Caching**: Each parameter combination cached separately

```typescript
// First call - generates with "active" status
await getOffers({ filter: "active" });

// Second call - cache miss, different params
// Generates new data with "pending" status
await getOffers({ filter: "pending" });

// Third call - cache hit for "active"
await getOffers({ filter: "active" });
```

### Best Practices

**Clear Variable Names**

```typescript
// Good - descriptive
instruction: "Generate {{userType}} users with {{subscriptionTier}} subscription"

// Avoid - unclear
instruction: "Generate {{type}} users with {{tier}}"
```

**Provide Defaults**

```typescript
// Handling missing variables
const params = {
  filter: filter || "all",
  status: status || "active"
};

await getOrders(params);
```

**Combine with Path Parameters**

```typescript
export const getProjectTasks = defineEndpoint<Task[]>({
  path: "/api/projects/:projectId/tasks",
  method: "GET",
  schema: TaskSchema,
  mock: {
    instruction: "Generate {{status}} tasks for {{projectType}} project"
  }
});

// Both path param and query params
const tasks = await getProjectTasks({
  projectId: "abc-123",      // Path parameter
  status: "in-progress",     // Instruction variable
  projectType: "enterprise"  // Instruction variable
});
```

## Error Handling

You can define custom error responses for your endpoints, which will be included in the OpenAPI specification and can be used for testing error states.

### Basic Error Configuration

```typescript
export const getUser = defineEndpoint({
  path: "/api/users/:id",
  method: "GET",
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  errors: [
    {
      code: 404,
      description: "User not found",
      schema: m.object({
        error: m.object({
          message: m.string(),
          code: m.string(),
          userId: m.uuid(),
        }),
      }),
    },
    {
      code: 403,
      description: "Insufficient permissions",
      schema: m.object({
        error: m.object({
          message: m.string(),
          requiredPermission: m.string(),
        }),
      }),
    },
  ],
});
```

### Testing Error States with `failNow`

Use the `failNow` flag to simulate error responses during development (mock mode only):

```typescript
export const createUser = defineEndpoint({
  path: "/api/users",
  method: "POST",
  schema: m.object({
    id: m.uuid(),
    name: m.string(),
    email: m.email(),
  }),
  errors: [
    {
      code: 400,
      description: "Invalid user data",
      schema: m.object({
        error: m.object({
          message: m.string(),
          validationErrors: m.array(
            m.object({
              field: m.string(),
              message: m.string(),
            })
          ),
        }),
      }),
      failNow: true, // Request will fail with this error in mock mode
    },
  ],
});

// In development/mock mode, this will throw an error:
try {
  await createUser({ name: "John" });
} catch (error) {
  console.error(error.message); // "[Symulate Mock] HTTP 400: Invalid user data"
  console.log(error.status);    // 400
  console.log(error.data);      // Generated error data matching the schema
}
```

**Note:** The `failNow` flag only affects mock mode (development). In production mode, requests will be sent to your real backend regardless of this flag.

### Default Error Responses

If no `errors` are specified, the OpenAPI spec will include default error responses (400, 404, 500) with a standard error schema.

## Type Validation

Symulate automatically validates backend responses in production mode:

```typescript
import { TypeValidationError } from "@symulate/sdk";

try {
  const users = await getUsers();
} catch (error) {
  if (error instanceof TypeValidationError) {
    console.error("Validation failed at:", error.path);
    console.error("Expected:", error.expected);
    console.error("Received:", error.received);
  }
}
```

## Local Development

Developing or testing the SDK with local/test Supabase instances? See **[DEVELOPMENT.md](DEVELOPMENT.md)** for instructions on using environment variables to override production URLs.

**Quick start:**
```bash
cp .env.example .env.local
# Edit .env.local with your test credentials
npm run build
```

## Documentation

For full documentation, visit the [main repository](https://github.com/yourusername/Symulate).

## License

MIT
